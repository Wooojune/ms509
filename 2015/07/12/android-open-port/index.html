<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>浅谈Android开放网络端口的安全风险 | MS509 Team</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">浅谈Android开放网络端口的安全风险</h1><a id="logo" href="/.">MS509 Team</a><p class="description">Mission Studio</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/contact/"><i class="fa fa-comments"> 联系</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">浅谈Android开放网络端口的安全风险</h1><div class="post-meta">2015-07-12<span> | </span><span class="category"><a href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/">移动安全</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.4k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 14</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>本文曾发表于乌云知识库，链接地址<a href="http://www.ms509.com/2015/07/12/android-open-port/" target="_blank" rel="noopener">http://www.ms509.com/2015/07/12/android-open-port/</a></p>
<h3 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h3><p>Android应用通常使用PF_UNIX、PF_INET、PF_NETLINK等不同domain的socket来进行本地IPC或者远程网络通信，这些暴露的socket代表了潜在的本地或远程攻击面，历史上也出现过不少利用socket进行拒绝服务、root提权或者远程命令执行的案例。特别是PF_INET类型的网络socket，可以通过网络与Android应用通信，其原本用于linux环境下开放网络服务，由于缺乏对网络调用者身份或者本地调用者pid、permission等细粒度的安全检查机制，在实现不当的情况下，可以突破Android的沙箱限制，以被攻击应用的权限执行命令，通常出现比较严重的漏洞。作为Android安全研究的新手，笔者带着传统服务器渗透寻找开放socket端口的思路，竟然也刷了不少漏洞，下面就对这种漏洞的发现、案例及影响进行归纳。</p>
<h3 id="0x01-Android开放端口应用定位"><a href="#0x01-Android开放端口应用定位" class="headerlink" title="0x01 Android开放端口应用定位"></a>0x01 Android开放端口应用定位</h3><p>简单地利用命令netstat就可以发现Android开放了许多socket端口，如图。但这些开放端口本后的应用却不得而知。</p>
<p><img src="/2015/07/12/android-open-port/allports.png" alt="image"></p>
<p>此时可以通过三步定位法进行寻找（感谢@瘦蛟舞的<a href="android-open-port/http://zone.wooyun.org/content/20410">帖子</a>），支持非root手机。</p>
<p>第一步，利用netstat寻找感兴趣的开放socket端口，如图中的15555。</p>
<p>第二步，将端口转换为十六进制值，查看位于/proc/net/目录下对应的socket套接字状态文件，在其中找到使用该socket的应用的uid。如15555的十六进制表示为1cc3，协议类型为tcp6，那么查看/proc/net/tcp6文件。</p>
<p><img src="/2015/07/12/android-open-port/findport2.png" alt="image"><br>注意上面的10115，就是使用该socket的应用的uid。通过这个uid可以得知应用的用户名为u0_a115。</p>
<p>第三步，根据用户名就可以找到应用了<br><img src="/2015/07/12/android-open-port/findport3.png" alt="image"><br>至此，我们就知道开放15555端口的应用为com.qiyi.video，尽管我们还不能分辨出开放该端口的准确进程，但仍然为进一步的漏洞挖掘打下基础。</p>
<p>写一个简单的脚本来自动化的完成此项工作.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">import subprocess,re </span><br><span class="line"></span><br><span class="line">def toHexPort(port):</span><br><span class="line">    hexport &#x3D; str(hex(int(port)))</span><br><span class="line">    return hexport.strip(&#39;0x&#39;).upper()</span><br><span class="line"></span><br><span class="line">def finduid(protocol, entry):</span><br><span class="line">    if (protocol&#x3D;&#x3D;&#39;tcp&#39; or protocol&#x3D;&#x3D;&#39;tcp6&#39;):</span><br><span class="line">        uid &#x3D; entry.split()[-10]</span><br><span class="line">    else: # udp or udp6</span><br><span class="line">        uid &#x3D; entry.split()[-6]</span><br><span class="line">    uid &#x3D; int(uid)</span><br><span class="line">    if (uid &gt; 10000): # just for non-system app</span><br><span class="line">        return &#39;u0_a&#39;+str(uid-10000) </span><br><span class="line">    else:</span><br><span class="line">        return -1</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    netstat_cmd &#x3D; &quot;adb shell netstat | grep -Ei &#39;listen|udp*&#39;&quot;</span><br><span class="line">    #netstat_cmd &#x3D; &quot;adb shell netstat &quot;</span><br><span class="line">    grep_cmd &#x3D; &quot;adb shell grep&quot; </span><br><span class="line">    proc_net &#x3D; &quot;&#x2F;proc&#x2F;net&#x2F;&quot;</span><br><span class="line">    </span><br><span class="line"># step 1, find interesting port</span><br><span class="line">    orig_output &#x3D; subprocess.check_output(netstat_cmd, shell&#x3D;True)</span><br><span class="line">    list_line &#x3D; orig_output.split(&#39;\r\n&#39;)</span><br><span class="line">    </span><br><span class="line">    apps &#x3D; []</span><br><span class="line">    strip_listline &#x3D; []</span><br><span class="line">    pattern &#x3D; re.compile(&quot;^Proto&quot;) # omit the first line</span><br><span class="line">    </span><br><span class="line">    for line in list_line:</span><br><span class="line">        if (line !&#x3D; &#39;&#39;) and (pattern.match(line)&#x3D;&#x3D;None):</span><br><span class="line">        </span><br><span class="line"># step 2, find uid in &#x2F;proc&#x2F;net&#x2F;[protocol] based on port </span><br><span class="line">            socket_entry &#x3D; line.split()</span><br><span class="line">            protocol &#x3D; socket_entry[0]  </span><br><span class="line">            port &#x3D; socket_entry[3].split(&#39;:&#39;)[-1]</span><br><span class="line">            grep_appid &#x3D; grep_cmd+&#39; &#39;+ toHexPort(port)+&#39; &#39;+proc_net + protocol </span><br><span class="line">            net_entry &#x3D; subprocess.check_output(grep_appid, shell&#x3D;True)</span><br><span class="line">            uid &#x3D; finduid(protocol, net_entry)</span><br><span class="line"># step 3, find app username based on uid</span><br><span class="line">            if (uid &#x3D;&#x3D; -1): continue</span><br><span class="line">            applist &#x3D; subprocess.check_output(&#39;adb shell ps | grep &#39;+uid, shell&#x3D;True).split()</span><br><span class="line">            app &#x3D; applist[8]</span><br><span class="line">            apps.append(app)</span><br><span class="line">            strip_listline.append(line)</span><br><span class="line">            </span><br><span class="line">    itapp&#x3D; iter(apps)</span><br><span class="line">    itline&#x3D;iter(strip_listline)</span><br><span class="line"># last, add app in orig_output of sockets</span><br><span class="line">    print (&quot;Package                  Proto Recv-Q Send-Q         Local Address          Foreign Address        State\r\n&quot;)</span><br><span class="line">    try:</span><br><span class="line">        while True:</span><br><span class="line">            print itapp.next()+&#39; &#39;+itline.next()</span><br><span class="line">    except StopIteration:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行结果如下<br><img src="/2015/07/12/android-open-port/result.png" alt="image"></p>
<p>除了PF_INET套接字外，PF_UNIX、PF_NETLINK套接字的状态文件分别位于/proc/net/unix和/proc/net/netlink。</p>
<p>当然，如果手机已root，可直接使用busybox安装目录下带p参数的netstat命令，可以显示pid和不完整的program name。<br><img src="/2015/07/12/android-open-port/rootresult.png" alt="image"></p>
<h3 id="0x02-漏洞挖掘实例"><a href="#0x02-漏洞挖掘实例" class="headerlink" title="0x02 漏洞挖掘实例"></a>0x02 漏洞挖掘实例</h3><p>得知某个应用开放某个端口以后，接下就可以在该应用的逆向代码中搜索端口号（通常是端口号的16进制表示），重点关注ServerSocket(tcp)、DatagramSocket(udp)等类，定位到关键代码，进一步探索潜在的攻击面，下面列举一些漏洞实例。</p>
<h4 id="敏感信息泄露、控制手机"><a href="#敏感信息泄露、控制手机" class="headerlink" title="敏感信息泄露、控制手机"></a>敏感信息泄露、控制手机</h4><p><a href="android-open-port/http://www.wooyun.org/bugs/wooyun-2010-094537">WooYun-2015-94537</a>：某service打开udp的65502端口监听，接收特定的命令字后可返回手机的敏感信息，包括手机助手远程管理手机的SecretKey，进而未授权的攻击者可通过网络完全管理手机。</p>
<p><a href="android-open-port/http://www.securityfocus.com/archive/1/534643">CVE-2014-8757</a>, LG On-Screen Phone预装App认证绕过漏洞。</p>
<h4 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h4><p>这类漏洞比较常见，通常通过开放socket端口传入启动android应用组件的intent，然后以被攻击应用的权限执行启动activity、发送广播等操作。由于通过socket传入的intent，无法对发送者的身份和权限进行细粒度检查，绕过了Android提供的对应用组件的权限保护，能够启动未导出的和受权限保护的应用组件，对安全造成影响。</p>
<p>如果监听的端口是在本地，那么可能造成本地命令执行和权限提升，而如果监听的端口是任意地址，则可能造成比较严重的远程命令执行。</p>
<p>本地命令执行：</p>
<p>用前面端口应用定位的方法，发现某流行应用实现了一个小型的HTTP Server，监听本地的9527端口，简单搜索分析即可发现向该端口发送如下形式的HTTP请求时可执行命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:9527&#x2F;si?cmp&#x3D;&lt;pacakgename&gt;_&lt;componentname&gt;&amp;data&#x3D;&lt;url scheme&gt;&amp;act&#x3D;&lt;action name&gt;</span><br></pre></td></tr></table></figure>

<p>通过这个简单的HTTP请求，恶意程序就可以传入intent对象的包名、组件名、url和action，接收HTTP请求后执行命令的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        if(v3.hasNext()) &#123;</span><br><span class="line">            Object v6 &#x3D; v3.next();</span><br><span class="line">            if(&quot;act&quot;.equals(v6)) &#123;</span><br><span class="line">                v4.setAction(v10.b.get(v6));</span><br><span class="line">            &#125;</span><br><span class="line">            if(&quot;cmp&quot;.equals(v6)) &#123;</span><br><span class="line">                String[] v9 &#x3D; v10.b.get(v6).split(&quot;_&quot;);</span><br><span class="line">                if(v9 &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    goto label_39;</span><br><span class="line">                &#125;</span><br><span class="line">                if(v9.length !&#x3D; 2) &#123;</span><br><span class="line">                    goto label_39;</span><br><span class="line">                &#125;</span><br><span class="line">                v4.setComponent(new ComponentName(v9[0], v9[1]));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        label_39:</span><br><span class="line"></span><br><span class="line">            if(&quot;data&quot;.equals(v6)) &#123;</span><br><span class="line">                v4.setData(Uri.parse(v10.b.get(v6)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if(!&quot;callback&quot;.equals(v6)) &#123;</span><br><span class="line">                goto label_13;</span><br><span class="line">            &#125;</span><br><span class="line">            Object v1_1 &#x3D; v10.b.get(v6);</span><br><span class="line">            goto label_13;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if((TextUtils.isEmpty(v4.getAction())) &amp;&amp; v4.getComponent() &#x3D;&#x3D; null &amp;&amp; v4.getData() &#x3D;&#x3D; null) &#123;</span><br><span class="line"></span><br><span class="line">            if(TextUtils.isEmpty(((CharSequence)v1))) &#123;</span><br><span class="line">                return &quot;&#123;\&quot;result\&quot;:-20000&#125;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.a(v1, &quot;&#123;\&quot;result\&quot;:-20000&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        List v0 &#x3D; this.a.getPackageManager().queryIntentActivities(v4, 0);</span><br><span class="line">        if(v0.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            if(TextUtils.isEmpty(((CharSequence)v1))) &#123;</span><br><span class="line">                return &quot;&#123;\&quot;result\&quot;:-10000&#125;&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            return this.a(v1, &quot;&#123;\&quot;result\&quot;:-10000&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.a.startActivity(v4);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>最终通过HTTP请求设置的Intent对象，传入了startActivity方法，由于需要用户干预，危害并不大。但当packagename指定为该应用自身，componentname指定为该应用的activity时，可以启动该应用的任意activity，包括受保护的未导出activity，从而对安全造成影响。例如，通过HTTP请求，逐一启动若干未导出的activity，可以发现拒绝服务漏洞、对安全有影响的登录界面和有一个可以该应用权限执行任意命令的GUI shell。</p>
<p>远程命令执行：</p>
<ol>
<li><p>趋势科技曾经发现过美团客户端漏洞，可以通过TCP的9527端口传入intent data，进而启动activity，见参考文献[1].</p>
</li>
<li><p>远程强制webview访问恶意链接</p>
</li>
</ol>
<p>定位到某流行应用实现了一个小型的HTTP Server，在tcp的6677端口监听任意地址，当HTTP请求满足一定条件时可以返回敏感信息，并根据请求消息执行一系列动作。对于该HTTP请求，仅有的防御措施是通过referer白名单的方式判断HTTP请求的来源。在正确设置referer，发送如下HTTP GET请求后</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip:6677&#x2F;command?param1&#x3D;value1&amp;...&amp;paramn&#x3D;valuen</span><br></pre></td></tr></table></figure>

<p>可获取手机的敏感信息和实现命令执行。其中command为getpackageinfo、androidamap、geolocation中的其一，见如下代码片段。<br><img src="/2015/07/12/android-open-port/command.png" alt="image"></p>
<p>（1）当command为geolocation时，可返回安装该应用手机地理位置信息；</p>
<p>（2）当command为getpackageinfo时，默认返回该应用自身的版本信息。此时若指定参数param1为packagename,即请求<a href="http://ip:6677/getpackageinfo?packagename=xxx时（xxx为软件包名）可返回手机上安装的xxx所指定的任意软件包版本信息。若xxx为android，可返回android系统版本信息；" target="_blank" rel="noopener">http://ip:6677/getpackageinfo?packagename=xxx时（xxx为软件包名）可返回手机上安装的xxx所指定的任意软件包版本信息。若xxx为android，可返回android系统版本信息；</a></p>
<p>（3）当command为androidamap时，设置Intent并将其广播出去，查看对应的OnReceive方法<br><img src="/2015/07/12/android-open-port/onreceive.png" alt="image"><br>发现需要指定参数param1为action,即请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip:6677&#x2F;androidamap?action&#x3D;yyy&amp;param2&#x3D;value2&amp;...&amp;paramn&#x3D;valuen</span><br></pre></td></tr></table></figure>
<p>时，OnReceive方法取出前面广播intent对象的extra，新建一个intent对象，设置intent uri为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">androidamap:&#x2F;&#x2F;yyy?sourceApplication&#x3D;web&amp;param2&#x3D;value2&amp;...&amp;paramn&#x3D;valuen</span><br></pre></td></tr></table></figure>
<p>，并以隐式intent的形式启动注册这种uri scheme的activiy。</p>
<p>进一步搜索发现如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Uri v0_2 &#x3D; Uri.parse(&quot;androidamap:&#x2F;&#x2F;openFeature?featureName&#x3D;OpenURL&amp;sourceApplication&#x3D;banner&amp;urlType&#x3D;0&amp;contentType&#x3D;autonavi&amp;url&#x3D;&quot;</span><br><span class="line">                             + this.a.m.privilegeLink);</span><br><span class="line">	Intent v1 &#x3D; new Intent(MovieDetailHeaderView.c(this.a).getApplicationContext(), </span><br><span class="line">                            NewMapActivity.class);</span><br><span class="line">	v1.setData(v0_2);</span><br><span class="line">	v1.setFlags(268435456);</span><br><span class="line">	MovieDetailHeaderView.c(this.a).startActivity(v1);</span><br></pre></td></tr></table></figure>
<p>表明可以通过远程HTTP GET请求如下地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip:6677&#x2F;androidamap?action&#x3D;openFeature&amp;featureName&#x3D;OpenURL&amp;sourceApplication&#x3D;banner&amp;urlType&#x3D;0&amp;contentType&#x3D;autonavi&amp;url&#x3D;evilsite</span><br></pre></td></tr></table></figure>
<p>操纵安装该app的手机继承WebView的Activity访问evilsite，而且这里存在WebView的漏洞，利用方式包括</p>
<p>(1). 窃取私有目录下的敏感文件：远程攻击者或者本地恶意app可以令WebView加载file://域的恶意脚本文件，按照恶意脚本的请求，窃取该应用私有目录下的敏感文件，突破android沙箱限制；</p>
<p>(2). WebView远程命令执行：存在可被网页中js操纵的接口jsinterface。由于该流行应用针对的SDK版本较低（android:minSdkVersion=”8”），在Android 4.4.2以下的手机，均可使用该接口，通过js注入该应用进程执行命令。 </p>
<h3 id="0x03-漏洞利用场景"><a href="#0x03-漏洞利用场景" class="headerlink" title="0x03 漏洞利用场景"></a>0x03 漏洞利用场景</h3><p>对于Android app开放socket端口漏洞的远程利用场景，一般认为Android客户端都在内网，其利用主要还是在非安全的公共WiFi环境，通过对漏洞特征扫描即可利用。但在传统认为安全的移动互联网环境，笔者发现仍然可以扫描到其他开放端口的终端，因此也可以利用这种漏洞。</p>
<p>叙述之前，我们先对典型的移动通信网络架构进行简单的科普，一般教科书上的3G网络架构（WCDMA）如图。<br><img src="/2015/07/12/android-open-port/4g-network.jpg" alt="image"></p>
<p>包括以下组成部分：</p>
<ol>
<li><p>UE: 用户终端设备，就是手机，为用户提供电路域和分组域内的各种业务功能。</p>
</li>
<li><p>UTRAN: 陆地无线接入网，分为基站（Node B）和无线网络控制器（RNC）两部分。</p>
</li>
<li><p>CN: 核心网络，负责与其他网络的连接和对UE 的通信和管理。主要功能实体包括：</p>
<p> (1) MSC/VLR：提供CS(电路交换)域的呼叫控制、移动性管理、鉴权和加密等功能；</p>
<p> (2) GMSC：网关移动交换中心，充当移动网和固定网之间的移动关口局，承担路由分析、网间接续、网间结算等重要功能；</p>
<p> (3) SGSN：GPRS服务支持节点，提供PS（分组交换）域的路由转发、移动性管理、会话管理、鉴权和加密等功能；</p>
<p> (4) GGSN：网关GPRS支持节点，提供数据包在WCDMA 移动网和外部数据网之间的路由和封装，GGSN就好象是可寻址WCDMA移动网络中所有用户IP 的路由器，需要同外部网络交换路由信息。</p>
<p> (5) HLR：归属位置寄存器，提供用户的签约信息存放、新业务支持、增强的鉴权等功能。</p>
</li>
<li><p>External Networks：外部网络，包括ISDN和PSTN等电路交换网络，以及Internet等分组交换网络。</p>
</li>
</ol>
<p>简而言之，移动通信网络无非是大型的“局域网“，它们通过网关路由器（SGSN和GGSN）连上了Internet，进入到了互联网的世界。但是在某些移动通信网络的内部，不同的UE是可以互访的。以前面某应用开放6677端口为例，我们可以做一个简单的实验进行证明。</p>
<p>使用联通3G网络，查看当前IP地址。<br><img src="/2015/07/12/android-open-port/3gnetaddr.png" alt="image"></p>
<p>在相邻C段进行扫描，扫描到开放端口的手机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT --open -p6677 10.160.112.0&#x2F;24</span><br></pre></td></tr></table></figure>

<p>发现如下结果<br><img src="/2015/07/12/android-open-port/scan3g.png" alt="image"></p>
<p>这证明在移动网络中，不同的UE可以互访。因此如果开放上述socket端口的app存在漏洞，在移动网络中也是可以利用的。 </p>
<h3 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h3><p>对于客户端的远程漏洞利用，从攻击者的角度来看，通常更容易使用被动的方法，即通过欺骗、劫持或社工的方法来让客户端访问我的攻击载荷。然而，从笔者发现的漏洞案例来看，许多Android应用不正确地使用网络socket端口传入命令进行跨进程通信，而且对于本地应用环境，网络socket也先天缺乏细粒度的认证授权机制，因此把Android客户端当做服务器，使用“攻”的方法，主动向开放端口发送攻击载荷也是可行的。这种漏洞一旦存在，轻则本地提权，重则为远程利用的高危漏洞，3G移动网络允许UE互访更是加剧了这种风险。</p>
<p>此外，除PF_INET外，PF_UNIX、PF_NETLINK域的套接字也是值得关注的本地攻击面。</p>
<p>[1] <a href="http://blog.trendmicro.com/trendlabs-security-intelligence/open-socket-poses-risks-to-android-security-model" target="_blank" rel="noopener">http://blog.trendmicro.com/trendlabs-security-intelligence/open-socket-poses-risks-to-android-security-model</a></p>
</div><div class="tags"><a href="/tags/Android/"><i class="fa fa-tag"></i>Android</a></div><div class="post-nav"><a class="pre" href="/2015/10/24/Drozer-modules/">实战Drozer模块编写</a><a class="next" href="/2015/05/25/cve-2014-7911/">CVE-2014-7911安卓序列化漏洞分析</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB%E5%AE%89%E5%85%A8/">WEB安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/">二进制安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/">代码审计</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">信息收集</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/">内网渗透</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/">安全工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A4%BE%E4%BC%9A%E5%B7%A5%E7%A8%8B%E5%AD%A6/">社会工程学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%A7%BB%E5%8A%A8%E5%AE%89%E5%85%A8/">移动安全</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/%E5%86%B0%E8%9D%8E/" style="font-size: 15px;">冰蝎</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/%E7%99%BB%E9%99%86%E5%87%AD%E8%AF%81/" style="font-size: 15px;">登陆凭证</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/%E5%8E%9F%E5%88%9B%E6%BC%8F%E6%B4%9E/" style="font-size: 15px;">原创漏洞</a> <a href="/tags/CMS/" style="font-size: 15px;">CMS</a> <a href="/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/" style="font-size: 15px;">内网穿透</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/PWN/" style="font-size: 15px;">PWN</a> <a href="/tags/WAF%E7%BB%95%E8%BF%87/" style="font-size: 15px;">WAF绕过</a> <a href="/tags/%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/" style="font-size: 15px;">测试指南</a> <a href="/tags/%E6%9D%80%E6%AF%92%E8%BD%AF%E4%BB%B6/" style="font-size: 15px;">杀毒软件</a> <a href="/tags/Window/" style="font-size: 15px;">Window</a> <a href="/tags/Cknife/" style="font-size: 15px;">Cknife</a> <a href="/tags/%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7/" style="font-size: 15px;">审计工具</a> <a href="/tags/%E6%81%B6%E6%84%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 15px;">恶意程序</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/IOS/" style="font-size: 15px;">IOS</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/08/20/Behinder3-0-Beta3-PHP/">冰蝎3.0-分析系列 1-beta3-php</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/20/Behinder3-0-Beta2-PHP/">冰蝎3.0-分析系列 1-beta2-php</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/14/Wechat-Program/">微信小程序和公众号渗透测试指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/13/MysqlLogMonitor/">【工具开源】MysqlSql语句监控工具——MysqlLogMonitor</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/29/Dsmall-Code-Audit/">DSMall的那些洞，你能发现吗？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/24/Waf-Bypass-Sql/">WAF绕过奇技淫巧之SQL注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/Collect-login-credentials/">linux后渗透之收集登录凭证</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/Intranet-penetration/">内网渗透之内网穿透</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/27/Subrion-Cms-Code-Audit/">Subrion CMS 代码审计</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/19/Java-Debug/">Java无源码调试之英雄崛起</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.zerokeeper.com/" title="小李飞刀" target="_blank">小李飞刀</a><ul></ul><a href="http://cybersec.blog.51cto.com" title="网络空间安全的道与术" target="_blank">网络空间安全的道与术</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">MS509 Team.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>